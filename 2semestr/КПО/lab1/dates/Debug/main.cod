; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33519.0 

	TITLE	D:\лабы\2 семестр\кпо\лаб.1\dates\dates\Debug\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__D5A691B9_dates@pch DB 01H
__50A4683D_corecrt_math@h DB 01H
__3313218A_system_error DB 01H
__086A95F5_stdexcept DB 01H
__AD2CEE3A_xlocinfo DB 01H
__B2A50DF2_typeinfo DB 01H
__851B68E1_vcruntime_typeinfo@h DB 01H
__C3F45B66_stdafx@cpp DB 01H
__B555CCA8_memory DB 01H
__0ACA2D49_streambuf DB 01H
__F371FB77_stdio@h DB 01H
__AA7EA578_corecrt_stdio_config@h DB 01H
__70CD7892_xlocnum DB 01H
__A8CE9780_ios DB 01H
__D3D649AB_iterator DB 01H
__09FBC026_limits DB 01H
__94C99929_xiosbase DB 01H
__EE4A1E85_xlocale DB 01H
__99109BA7_xfacet DB 01H
__FD5AC441_ostream DB 01H
__9E8AF17B_istream DB 01H
__C1864A34_string DB 01H
__2F328FEB_utility DB 01H
__85F4241F_vcruntime_exception@h DB 01H
__C27AFEEB_xutility DB 01H
__A3D3E4E8_vcruntime_new@h DB 01H
__7C4A1519_type_traits DB 01H
__45A7EC28_xmemory DB 01H
__31746AB4_xstring DB 01H
__67153995_answer@cpp DB 01H
__DA04E707_birthday@cpp DB 01H
__47025CB3_parameters@cpp DB 01H
__3B25FD95_main@cpp DB 01H
__F25AC591_month_and_day@cpp DB 01H
__20BB3D25_stdafx@h DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	_main
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@IGIKFMFC@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@LJPJJNIE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@	; `string'
PUBLIC	??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GC@HPEHFALL@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@FHHFGEFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0BA@LCFMICKJ@?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?3@ ; `string'
PUBLIC	??_C@_0BC@CIPPACFL@?c?n?d?5?m?e?b?h?q?n?j?n?q?m?$PL?i?3@ ; `string'
PUBLIC	??_C@_03EJKFMIHK@rus@				; `string'
PUBLIC	??_C@_0BP@GFHHDGAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?e?5?D?D?L?L?C?C?C?C?3@ ; `string'
PUBLIC	??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@ ; `string'
PUBLIC	??_C@_0CF@HCFCKKAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?e?5?D@ ; `string'
PUBLIC	??_C@_0O@BNFNCAFF@?6?p?e?g?s?k?$PM?r?$OA?r?5?$DN?5@ ; `string'
PUBLIC	??_C@_0DC@FIDMDLFP@?6?b?b?e?d?h?r?e?51?0?5?w?r?n?a?$PL?5?o?p?n?d?n?k?f?h?r?$PM?0?52@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__strtol:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xinvalid_argument@std@@YAXPBD@Z:PROC		; std::_Xinvalid_argument
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp__setlocale:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DC@FIDMDLFP@?6?b?b?e?d?h?r?e?51?0?5?w?r?n?a?$PL?5?o?p?n?d?n?k?f?h?r?$PM?0?52@
CONST	SEGMENT
??_C@_0DC@FIDMDLFP@?6?b?b?e?d?h?r?e?51?0?5?w?r?n?a?$PL?5?o?p?n?d?n?k?f?h?r?$PM?0?52@ DB 0aH
	DB	0e2H, 0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' 1, ', 0f7H, 0f2H, 0eeH
	DB	0e1H, 0fbH, ' ', 0efH, 0f0H, 0eeH, 0e4H, 0eeH, 0ebH, 0e6H, 0e8H
	DB	0f2H, 0fcH, ', 2, ', 0f7H, 0f2H, 0eeH, 0e1H, 0fbH, ' ', 0e7H, 0e0H
	DB	0eaH, 0eeH, 0edH, 0f7H, 0e8H, 0f2H, 0fcH, ':', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNFNCAFF@?6?p?e?g?s?k?$PM?r?$OA?r?5?$DN?5@
CONST	SEGMENT
??_C@_0O@BNFNCAFF@?6?p?e?g?s?k?$PM?r?$OA?r?5?$DN?5@ DB 0aH, 0f0H, 0e5H, 0e7H
	DB	0f3H, 0ebH, 0fcH, 0f2H, 0e0H, 0f2H, ' = ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HCFCKKAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?e?5?D@
CONST	SEGMENT
??_C@_0CF@HCFCKKAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?e?5?D@ DB 0e2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e4H, 0e0H, 0f2H, 0f3H
	DB	' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ' ', 0e2H
	DB	' ', 0f4H, 0eeH, 0f0H, 0ecH, 0e5H, ' ', 0c4H, 0c4H, 0ccH, 0ccH
	DB	': ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@
CONST	SEGMENT
??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@ DB 0e2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0edH, 0e5H, 0efH
	DB	0f0H, 0e0H, 0e2H, 0e8H, 0ebH, 0fcH, 0edH, 0f3H, 0feH, ' ', 0e4H
	DB	0e0H, 0f2H, 0f3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GFHHDGAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?e?5?D?D?L?L?C?C?C?C?3@
CONST	SEGMENT
??_C@_0BP@GFHHDGAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?e?5?D?D?L?L?C?C?C?C?3@ DB 0e2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e4H, 0e0H, 0f2H, 0f3H
	DB	' ', 0e2H, ' ', 0f4H, 0eeH, 0f0H, 0ecH, 0e5H, ' ', 0c4H, 0c4H, 0ccH
	DB	0ccH, 0c3H, 0c3H, 0c3H, 0c3H, ':', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EJKFMIHK@rus@
CONST	SEGMENT
??_C@_03EJKFMIHK@rus@ DB 'rus', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CIPPACFL@?c?n?d?5?m?e?b?h?q?n?j?n?q?m?$PL?i?3@
CONST	SEGMENT
??_C@_0BC@CIPPACFL@?c?n?d?5?m?e?b?h?q?n?j?n?q?m?$PL?i?3@ DB 0e3H, 0eeH, 0e4H
	DB	' ', 0edH, 0e5H, 0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH
	DB	0fbH, 0e9H, ':', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LCFMICKJ@?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?3@
CONST	SEGMENT
??_C@_0BA@LCFMICKJ@?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?3@ DB 0e3H, 0eeH, 0e4H, ' '
	DB	0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH, 0fbH, 0e9H, ':'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@FHHFGEFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@FHHFGEFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '9', 00H, '.', 00H, '3', 00H, '3', 00H, '5'
	DB	00H, '1', 00H, '9', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@HPEHFALL@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@HPEHFALL@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'39.33519\include\xstring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@ DB 'string subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ DB 'stoi argument out '
	DB	'of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
CONST	SEGMENT
??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@ DB 'invalid stoi argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@LJPJJNIE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@LJPJJNIE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '9', 00H, '.', 00H, '3', 00H, '3', 00H, '5'
	DB	00H, '1', 00H, '9', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@IGIKFMFC@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@IGIKFMFC@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'39.33519\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 09eH ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	0278H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	071H
	DB	07eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	076aH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	01H
	DD	FLAT:__unwindfunclet$_main$2
	DD	02H
	DD	FLAT:__unwindfunclet$_main$3
	DD	03H
	DD	FLAT:__unwindfunclet$_main$4
	DD	04H
	DD	FLAT:__unwindfunclet$_main$5
	DD	05H
	DD	FLAT:__unwindfunclet$_main$6
	DD	06H
	DD	FLAT:__unwindfunclet$_main$7
	DD	07H
	DD	FLAT:__unwindfunclet$_main$8
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	03faH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0156H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	01d3H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0
__ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	0c2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	090H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	0adH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	090H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	076H
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 100  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __9E8AF17B_istream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 101  :             return _Ok;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 102  :         }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 98   :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0001e	b9 03 00 00 00	 mov	 ecx, 3
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __9E8AF17B_istream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	8b f4		 mov	 esi, esp
  0005e	0f b6 45 0c	 movzx	 eax, BYTE PTR __Noskip$[ebp]
  00062	50		 push	 eax
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0006e	3b f4		 cmp	 esi, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00078	88 42 04	 mov	 BYTE PTR [edx+4], al
  0007b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00082	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00088	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008f	59		 pop	 ecx
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 83   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0001e	b9 07 00 00 00	 mov	 ecx, 7
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __9E8AF17B_istream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 84   :             const auto _Rdbuf = _Myistr.rdbuf();

  00049	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00054	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0005a	8b 02		 mov	 eax, DWORD PTR [edx]
  0005c	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  00062	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00065	8b f4		 mov	 esi, esp
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	89 45 e0	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 85   :             if (_Rdbuf) {

  00077	83 7d e0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0007b	74 16		 je	 SHORT $LN2@Sentry_bas

; 86   :                 _Rdbuf->_Unlock();

  0007d	8b 45 e0	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00080	8b 10		 mov	 edx, DWORD PTR [eax]
  00082	8b f4		 mov	 esi, esp
  00084	8b 4d e0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00087	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008a	ff d0		 call	 eax
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Sentry_bas:

; 87   :             }
; 88   :         }

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
  000b2	cc		 int	 3
  000b3	cc		 int	 3
  000b4	cc		 int	 3
  000b5	cc		 int	 3
  000b6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __9E8AF17B_istream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx

; 77   :             const auto _Rdbuf = _Myistr.rdbuf();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  0003d	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0004b	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004e	8b f4		 mov	 esi, esp
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	89 45 ec	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 78   :             if (_Rdbuf) {

  00060	83 7d ec 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00064	74 16		 je	 SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Lock();

  00066	8b 45 ec	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	8b f4		 mov	 esi, esp
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00070	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00073	ff d0		 call	 eax
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv200 = -292						; size = 4
tv65 = -292						; size = 4
$T2 = -284						; size = 4
__Meta$3 = -80						; size = 4
__Metadelim$4 = -68					; size = 4
__Ok$ = -56						; size = 8
__Changed$ = -37					; size = 1
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 26   :     basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d 7d 9c	 lea	 edi, DWORD PTR [ebp-100]
  0001e	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET __C1864A34_string
  00046	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 27   :     // get characters into string, discard delimiter
; 28   :     using _Myis = basic_istream<_Elem, _Traits>;
; 29   : 
; 30   :     typename _Myis::iostate _State = _Myis::goodbit;

  0004b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 31   :     bool _Changed                  = false;

  00052	c6 45 db 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 32   :     const typename _Myis::sentry _Ok(_Istr, true);

  00056	6a 01		 push	 1
  00058	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005b	50		 push	 eax
  0005c	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0005f	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 33   : 
; 34   :     if (_Ok) { // state okay, extract characters

  0006b	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0006e	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  00073	0f b6 c0	 movzx	 eax, al
  00076	85 c0		 test	 eax, eax
  00078	0f 84 8c 01 00
	00		 je	 $LN18@getline

; 35   :         _TRY_IO_BEGIN

  0007e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 36   :         _Str.erase();

  00082	6a 00		 push	 0
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00087	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 37   :         const typename _Traits::int_type _Metadelim = _Traits::to_int_type(_Delim);

  0008c	0f b6 45 10	 movzx	 eax, BYTE PTR __Delim$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00096	83 c4 04	 add	 esp, 4
  00099	89 45 bc	 mov	 DWORD PTR __Metadelim$4[ebp], eax

; 38   :         typename _Traits::int_type _Meta            = _Istr.rdbuf()->sgetc();

  0009c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000a4	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000a7	8b f4		 mov	 esi, esp
  000a9	8b ca		 mov	 ecx, edx
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	8b f4		 mov	 esi, esp
  000ba	8b c8		 mov	 ecx, eax
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000c2	3b f4		 cmp	 esi, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  000cf	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  000d5	89 45 b0	 mov	 DWORD PTR __Meta$3[ebp], eax

; 39   : 
; 40   :         for (;; _Meta = _Istr.rdbuf()->snextc()) {

  000d8	eb 3c		 jmp	 SHORT $LN4@getline
$LN2@getline:
  000da	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000e5	8b f4		 mov	 esi, esp
  000e7	8b ca		 mov	 ecx, edx
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000ef	3b f4		 cmp	 esi, esp
  000f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f6	8b f4		 mov	 esi, esp
  000f8	8b c8		 mov	 ecx, eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00100	3b f4		 cmp	 esi, esp
  00102	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00107	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  0010d	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv200[ebp]
  00113	89 45 b0	 mov	 DWORD PTR __Meta$3[ebp], eax
$LN4@getline:

; 41   :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  00116	8b 45 b0	 mov	 eax, DWORD PTR __Meta$3[ebp]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00125	83 c4 08	 add	 esp, 8
  00128	0f b6 c8	 movzx	 ecx, al
  0012b	85 c9		 test	 ecx, ecx
  0012d	74 13		 je	 SHORT $LN7@getline

; 42   :                 _State |= _Myis::eofbit;

  0012f	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00132	83 c8 01	 or	 eax, 1
  00135	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 43   :                 break;

  00138	e9 95 00 00 00	 jmp	 $LN3@getline
  0013d	e9 8b 00 00 00	 jmp	 $LN12@getline
$LN7@getline:

; 44   :             } else if (_Traits::eq_int_type(_Meta, _Metadelim)) { // got a delimiter, discard it and quit

  00142	8b 45 bc	 mov	 eax, DWORD PTR __Metadelim$4[ebp]
  00145	50		 push	 eax
  00146	8b 4d b0	 mov	 ecx, DWORD PTR __Meta$3[ebp]
  00149	51		 push	 ecx
  0014a	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0014f	83 c4 08	 add	 esp, 8
  00152	0f b6 d0	 movzx	 edx, al
  00155	85 d2		 test	 edx, edx
  00157	74 35		 je	 SHORT $LN9@getline

; 45   :                 _Changed = true;

  00159	c6 45 db 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 46   :                 _Istr.rdbuf()->sbumpc();

  0015d	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00160	8b 08		 mov	 ecx, DWORD PTR [eax]
  00162	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00165	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00168	8b f4		 mov	 esi, esp
  0016a	8b ca		 mov	 ecx, edx
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00172	3b f4		 cmp	 esi, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00179	8b f4		 mov	 esi, esp
  0017b	8b c8		 mov	 ecx, eax
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00183	3b f4		 cmp	 esi, esp
  00185	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 47   :                 break;

  0018a	eb 46		 jmp	 SHORT $LN3@getline
  0018c	eb 3f		 jmp	 SHORT $LN12@getline
$LN9@getline:

; 48   :             } else if (_Str.max_size() <= _Str.size()) { // string too large, quit

  0018e	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00191	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00196	8b f0		 mov	 esi, eax
  00198	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0019b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  001a0	3b c6		 cmp	 eax, esi
  001a2	77 0d		 ja	 SHORT $LN11@getline

; 49   :                 _State |= _Myis::failbit;

  001a4	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  001a7	83 c8 02	 or	 eax, 2
  001aa	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 50   :                 break;

  001ad	eb 23		 jmp	 SHORT $LN3@getline

; 51   :             } else { // got a character, add it to string

  001af	eb 1c		 jmp	 SHORT $LN12@getline
$LN11@getline:

; 52   :                 _Str += _Traits::to_char_type(_Meta);

  001b1	8b 45 b0	 mov	 eax, DWORD PTR __Meta$3[ebp]
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  001ba	83 c4 04	 add	 esp, 4
  001bd	0f b6 c8	 movzx	 ecx, al
  001c0	51		 push	 ecx
  001c1	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001c4	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 53   :                 _Changed = true;

  001c9	c6 45 db 01	 mov	 BYTE PTR __Changed$[ebp], 1
$LN12@getline:

; 54   :             }
; 55   :         }

  001cd	e9 08 ff ff ff	 jmp	 $LN2@getline
$LN3@getline:
  001d2	eb 26		 jmp	 SHORT $LN15@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 56   :         _CATCH_IO_(_Myis, _Istr)

  001d4	8b f4		 mov	 esi, esp
  001d6	6a 01		 push	 1
  001d8	6a 04		 push	 4
  001da	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  001dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001df	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e5	8b ca		 mov	 ecx, edx
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001ed	3b f4		 cmp	 esi, esp
  001ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f4	b8 00 00 00 00	 mov	 eax, $LN19@getline
  001f9	c3		 ret	 0
$LN15@getline:
  001fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00201	eb 07		 jmp	 SHORT $LN18@getline
$LN19@getline:
  00203	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN18@getline:

; 57   :     }
; 58   : 
; 59   :     if (!_Changed) {

  0020a	0f b6 45 db	 movzx	 eax, BYTE PTR __Changed$[ebp]
  0020e	85 c0		 test	 eax, eax
  00210	75 09		 jne	 SHORT $LN13@getline

; 60   :         _State |= _Myis::failbit;

  00212	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00215	83 c8 02	 or	 eax, 2
  00218	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax
$LN13@getline:

; 61   :     }
; 62   : 
; 63   :     _Istr.setstate(_State);

  0021b	8b f4		 mov	 esi, esp
  0021d	6a 00		 push	 0
  0021f	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00222	50		 push	 eax
  00223	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00226	8b 11		 mov	 edx, DWORD PTR [ecx]
  00228	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0022b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00234	3b f4		 cmp	 esi, esp
  00236	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 64   :     return static_cast<basic_istream<_Elem, _Traits>&>(_Istr);

  0023b	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0023e	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00244	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0024b	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0024e	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00253	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 65   : }

  00259	52		 push	 edx
  0025a	8b cd		 mov	 ecx, ebp
  0025c	50		 push	 eax
  0025d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN23@getline
  00263	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00268	58		 pop	 eax
  00269	5a		 pop	 edx
  0026a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0026d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00274	59		 pop	 ecx
  00275	5f		 pop	 edi
  00276	5e		 pop	 esi
  00277	5b		 pop	 ebx
  00278	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027b	33 cd		 xor	 ecx, ebp
  0027d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00282	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  00288	3b ec		 cmp	 ebp, esp
  0028a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028f	8b e5		 mov	 esp, ebp
  00291	5d		 pop	 ebp
  00292	c3		 ret	 0
  00293	90		 npad	 1
$LN23@getline:
  00294	01 00 00 00	 DD	 1
  00298	00 00 00 00	 DD	 $LN22@getline
$LN22@getline:
  0029c	c8 ff ff ff	 DD	 -56			; ffffffc8H
  002a0	08 00 00 00	 DD	 8
  002a4	00 00 00 00	 DD	 $LN20@getline
$LN20@getline:
  002a8	5f		 DB	 95			; 0000005fH
  002a9	4f		 DB	 79			; 0000004fH
  002aa	6b		 DB	 107			; 0000006bH
  002ab	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a d8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-296]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 128  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __FD5AC441_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  :             return _Ok;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 130  :         }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -217						; size = 1
__Zero_uncaught_exceptions$ = -17			; size = 1
_this$ = -8						; size = 4
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 113  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __FD5AC441_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 114  : #if !_HAS_EXCEPTIONS
; 115  :             const bool _Zero_uncaught_exceptions = true;
; 116  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  0002a	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	75 09		 jne	 SHORT $LN4@sentry
  00036	c6 85 27 ff ff
	ff 01		 mov	 BYTE PTR tv72[ebp], 1
  0003d	eb 07		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  0003f	c6 85 27 ff ff
	ff 00		 mov	 BYTE PTR tv72[ebp], 0
$LN5@sentry:
  00046	8a 8d 27 ff ff
	ff		 mov	 cl, BYTE PTR tv72[ebp]
  0004c	88 4d ef	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 118  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 119  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 120  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 121  : 
; 122  :             if (_Zero_uncaught_exceptions) {

  0004f	0f b6 45 ef	 movzx	 eax, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  00053	85 c0		 test	 eax, eax
  00055	74 14		 je	 SHORT $LN2@sentry

; 123  :                 this->_Myostr._Osfx();

  00057	8b f4		 mov	 esi, esp
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@sentry:

; 124  :             }
; 125  :         }

  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 96   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0001e	b9 06 00 00 00	 mov	 ecx, 6
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __FD5AC441_ostream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 97   :             if (!_Ostr.good()) {

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b f4		 mov	 esi, esp
  00069	8b ca		 mov	 ecx, edx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	0f b6 c0	 movzx	 eax, al
  0007b	85 c0		 test	 eax, eax
  0007d	75 09		 jne	 SHORT $LN2@sentry

; 98   :                 _Ok = false;

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00082	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 99   :                 return;

  00086	eb 6a		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 100  :             }
; 101  : 
; 102  :             const auto _Tied = _Ostr.tie();

  00088	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0008b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00090	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00093	8b f4		 mov	 esi, esp
  00095	8b ca		 mov	 ecx, edx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	89 45 e0	 mov	 DWORD PTR __Tied$[ebp], eax

; 103  :             if (!_Tied || _Tied == &_Ostr) {

  000a7	83 7d e0 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  000ab	74 08		 je	 SHORT $LN4@sentry
  000ad	8b 45 e0	 mov	 eax, DWORD PTR __Tied$[ebp]
  000b0	3b 45 08	 cmp	 eax, DWORD PTR __Ostr$[ebp]
  000b3	75 09		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 104  :                 _Ok = true;

  000b5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 105  :                 return;

  000bc	eb 34		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 106  :             }
; 107  : 
; 108  :             _Tied->flush();

  000be	8b f4		 mov	 esi, esp
  000c0	8b 4d e0	 mov	 ecx, DWORD PTR __Tied$[ebp]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 109  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000d0	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000d8	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000db	8b f4		 mov	 esi, esp
  000dd	8b ca		 mov	 ecx, edx
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	88 41 04	 mov	 BYTE PTR [ecx+4], al
$LN1@sentry:

; 110  :         }

  000f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00106	59		 pop	 ecx
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00110	3b ec		 cmp	 ebp, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 82   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0001e	b9 07 00 00 00	 mov	 ecx, 7
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __FD5AC441_ostream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 83   :             const auto _Rdbuf = _Myostr.rdbuf();

  00049	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00054	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0005a	8b 02		 mov	 eax, DWORD PTR [edx]
  0005c	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  00062	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00065	8b f4		 mov	 esi, esp
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	89 45 e0	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 84   :             if (_Rdbuf) {

  00077	83 7d e0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0007b	74 16		 je	 SHORT $LN2@Sentry_bas

; 85   :                 _Rdbuf->_Unlock();

  0007d	8b 45 e0	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00080	8b 10		 mov	 edx, DWORD PTR [eax]
  00082	8b f4		 mov	 esi, esp
  00084	8b 4d e0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00087	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008a	ff d0		 call	 eax
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Sentry_bas:

; 86   :             }
; 87   :         }

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
  000b2	cc		 int	 3
  000b3	cc		 int	 3
  000b4	cc		 int	 3
  000b5	cc		 int	 3
  000b6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __FD5AC441_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx

; 76   :             const auto _Rdbuf = _Myostr.rdbuf();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  0003d	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0004b	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004e	8b f4		 mov	 esi, esp
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	89 45 ec	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 77   :             if (_Rdbuf) {

  00060	83 7d ec 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00064	74 16		 je	 SHORT $LN2@Sentry_bas

; 78   :                 _Rdbuf->_Lock();

  00066	8b 45 ec	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	8b f4		 mov	 esi, esp
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00070	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00073	ff d0		 call	 eax
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@Sentry_bas:

; 79   :             }
; 80   :         }

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 83   :     basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __C1864A34_string
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 84   :     // get characters into string, discard newline
; 85   :     return _STD getline(_STD move(_Istr), _Str, _Istr.widen('\n'));

  00021	8b f4		 mov	 esi, esp
  00023	6a 0a		 push	 10			; 0000000aH
  00025	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0002d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00030	8b ca		 mov	 ecx, edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	0f b6 c0	 movzx	 eax, al
  00042	50		 push	 eax
  00043	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00046	51		 push	 ecx
  00047	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\лабы\2 семестр\кпо\лаб.1\dates\dates\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
$T2 = -1053						; size = 1
$T3 = -1041						; size = 1
$T4 = -1029						; size = 1
$T5 = -1017						; size = 1
$T6 = -1005						; size = 1
$T7 = -993						; size = 1
$T8 = -981						; size = 1
_expceptions_birthday$9 = -588				; size = 4
_month_of_birthday$10 = -576				; size = 4
_day_of_birthday$11 = -564				; size = 4
_expception_birthday$12 = -552				; size = 28
_monthes_of_birthday$13 = -516				; size = 28
_days_of_birthday$14 = -480				; size = 28
_i$15 = -444						; size = 4
_exceptions$16 = -432					; size = 4
_year$17 = -420						; size = 4
_month$18 = -408					; size = 4
_day$19 = -396						; size = 4
_exception$20 = -384					; size = 28
_years$21 = -348					; size = 28
_monthes$22 = -312					; size = 28
_days$23 = -276						; size = 28
_i$24 = -240						; size = 4
_birthday$25 = -228					; size = 28
_date$26 = -192						; size = 28
_quantity$27 = -156					; size = 4
_result_of_birthday$28 = -144				; size = 4
_result$29 = -132					; size = 4
_thirty_one$30 = -120					; size = 4
_thirty$31 = -108					; size = 4
_zero$32 = -96						; size = 4
_sum$33 = -84						; size = 4
_eight$34 = -72						; size = 4
_fourhungreed$35 = -60					; size = 4
_four$36 = -48						; size = 4
_TWELVE$37 = -36					; size = 4
_c$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 8    : int main() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 18 04 00
	00		 sub	 esp, 1048		; 00000418H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 5c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-676]
  00020	b9 a6 00 00 00	 mov	 ecx, 166		; 000000a6H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __3B25FD95_main@cpp
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 9    : 
; 10   : 	setlocale(LC_CTYPE, "rus");

  0004a	8b f4		 mov	 esi, esp
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_03EJKFMIHK@rus@
  00051	6a 02		 push	 2
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
  00059	83 c4 08	 add	 esp, 8
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 11   : 	int c = 1;

  00063	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _c$[ebp], 1
$LN4@main:

; 12   : 	
; 13   : 	do {
; 14   : 		
; 15   : 		const int TWELVE = 12;

  0006a	c7 45 dc 0c 00
	00 00		 mov	 DWORD PTR _TWELVE$37[ebp], 12 ; 0000000cH

; 16   : 		int four = 4, fourhungreed = 400, eight = 8, sum = 0, zero = 0, thirty = 30, thirty_one = 31, result, result_of_birthday, quantity;

  00071	c7 45 d0 04 00
	00 00		 mov	 DWORD PTR _four$36[ebp], 4
  00078	c7 45 c4 90 01
	00 00		 mov	 DWORD PTR _fourhungreed$35[ebp], 400 ; 00000190H
  0007f	c7 45 b8 08 00
	00 00		 mov	 DWORD PTR _eight$34[ebp], 8
  00086	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _sum$33[ebp], 0
  0008d	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _zero$32[ebp], 0
  00094	c7 45 94 1e 00
	00 00		 mov	 DWORD PTR _thirty$31[ebp], 30 ; 0000001eH
  0009b	c7 45 88 1f 00
	00 00		 mov	 DWORD PTR _thirty_one$30[ebp], 31 ; 0000001fH

; 17   : 		string date, birthday;

  000a2	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _date$26[ebp]
  000a8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ad	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b4	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _birthday$25[ebp]
  000ba	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000bf	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 18   : 
; 19   : 		cout << "введите дату в форме ДДММГГГГ:" << endl;

  000c3	8b f4		 mov	 esi, esp
  000c5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GFHHDGAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?e?5?D?D?L?L?C?C?C?C?3@
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000da	83 c4 08	 add	 esp, 8
  000dd	8b c8		 mov	 ecx, eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 20   : 		getline(cin, date);

  000ec	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _date$26[ebp]
  000f2	50		 push	 eax
  000f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  000f9	51		 push	 ecx
  000fa	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  000ff	83 c4 08	 add	 esp, 8

; 21   : 
; 22   : 		for (int i = 0; i < date.size(); i++) {

  00102	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$24[ebp], 0
  0010c	eb 0f		 jmp	 SHORT $LN7@main
$LN5@main:
  0010e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _i$24[ebp]
  00114	83 c0 01	 add	 eax, 1
  00117	89 85 10 ff ff
	ff		 mov	 DWORD PTR _i$24[ebp], eax
$LN7@main:
  0011d	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _date$26[ebp]
  00123	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00128	39 85 10 ff ff
	ff		 cmp	 DWORD PTR _i$24[ebp], eax
  0012e	73 75		 jae	 SHORT $LN6@main

; 23   : 			if ((date[i] > '9') || (date[i] < '0')) {

  00130	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _i$24[ebp]
  00136	50		 push	 eax
  00137	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _date$26[ebp]
  0013d	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00142	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00145	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00148	7f 1a		 jg	 SHORT $LN12@main
  0014a	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _i$24[ebp]
  00150	50		 push	 eax
  00151	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _date$26[ebp]
  00157	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0015c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0015f	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00162	7d 3c		 jge	 SHORT $LN11@main
$LN12@main:

; 24   : 				cout << "вы ввели неправильную дату" << endl;

  00164	8b f4		 mov	 esi, esp
  00166	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0017b	83 c4 08	 add	 esp, 8
  0017e	8b c8		 mov	 ecx, eax
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00186	3b f4		 cmp	 esi, esp
  00188	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 25   : 				exit(0);

  0018d	8b f4		 mov	 esi, esp
  0018f	6a 00		 push	 0
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00197	3b f4		 cmp	 esi, esp
  00199	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 26   : 				break;

  0019e	eb 05		 jmp	 SHORT $LN6@main
$LN11@main:

; 27   : 			}
; 28   : 		}

  001a0	e9 69 ff ff ff	 jmp	 $LN5@main
$LN6@main:

; 29   : 		
; 30   : 		if (date.size() == eight) {

  001a5	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _date$26[ebp]
  001ab	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  001b0	3b 45 b8	 cmp	 eax, DWORD PTR _eight$34[ebp]
  001b3	0f 85 f6 04 00
	00		 jne	 $LN13@main

; 31   : 
; 32   : 			string days(date, 0, 2);

  001b9	8d 8d 2b fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  001bf	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  001c4	50		 push	 eax
  001c5	6a 02		 push	 2
  001c7	6a 00		 push	 0
  001c9	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _date$26[ebp]
  001cf	50		 push	 eax
  001d0	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _days$23[ebp]
  001d6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001db	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 33   : 			string monthes(date, 2, 2);

  001df	8d 8d 1f fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  001e5	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  001ea	50		 push	 eax
  001eb	6a 02		 push	 2
  001ed	6a 02		 push	 2
  001ef	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _date$26[ebp]
  001f5	50		 push	 eax
  001f6	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _monthes$22[ebp]
  001fc	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00201	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 34   : 			string years(date, 4, 4);

  00205	8d 8d 13 fc ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0020b	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00210	50		 push	 eax
  00211	6a 04		 push	 4
  00213	6a 04		 push	 4
  00215	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _date$26[ebp]
  0021b	50		 push	 eax
  0021c	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _years$21[ebp]
  00222	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00227	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 35   : 			string exception(date, 0, 4);

  0022b	8d 8d 07 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00231	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00236	50		 push	 eax
  00237	6a 04		 push	 4
  00239	6a 00		 push	 0
  0023b	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _date$26[ebp]
  00241	50		 push	 eax
  00242	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _exception$20[ebp]
  00248	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0024d	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 36   : 
; 37   : 			int day = stoi(days);

  00251	6a 0a		 push	 10			; 0000000aH
  00253	6a 00		 push	 0
  00255	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _days$23[ebp]
  0025b	50		 push	 eax
  0025c	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  00261	83 c4 0c	 add	 esp, 12			; 0000000cH
  00264	89 85 74 fe ff
	ff		 mov	 DWORD PTR _day$19[ebp], eax

; 38   : 			int month = stoi(monthes);

  0026a	6a 0a		 push	 10			; 0000000aH
  0026c	6a 00		 push	 0
  0026e	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _monthes$22[ebp]
  00274	50		 push	 eax
  00275	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  0027a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027d	89 85 68 fe ff
	ff		 mov	 DWORD PTR _month$18[ebp], eax

; 39   : 			int year = stoi(years);

  00283	6a 0a		 push	 10			; 0000000aH
  00285	6a 00		 push	 0
  00287	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _years$21[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  00293	83 c4 0c	 add	 esp, 12			; 0000000cH
  00296	89 85 5c fe ff
	ff		 mov	 DWORD PTR _year$17[ebp], eax

; 40   : 			int exceptions = stoi(exception);

  0029c	6a 0a		 push	 10			; 0000000aH
  0029e	6a 00		 push	 0
  002a0	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _exception$20[ebp]
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	89 85 50 fe ff
	ff		 mov	 DWORD PTR _exceptions$16[ebp], eax

; 41   : 
; 42   : 			cout << "введите дату рождения в форме ДДММ: " << endl;

  002b5	8b f4		 mov	 esi, esp
  002b7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HCFCKKAG@?b?b?e?d?h?r?e?5?d?$OA?r?s?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?e?5?D@
  002c1	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002cc	83 c4 08	 add	 esp, 8
  002cf	8b c8		 mov	 ecx, eax
  002d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  002d7	3b f4		 cmp	 esi, esp
  002d9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 43   : 			getline(cin, birthday);

  002de	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _birthday$25[ebp]
  002e4	50		 push	 eax
  002e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  002eb	51		 push	 ecx
  002ec	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  002f1	83 c4 08	 add	 esp, 8

; 44   : 			
; 45   : 				if (birthday.size() == four) {

  002f4	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _birthday$25[ebp]
  002fa	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  002ff	3b 45 d0	 cmp	 eax, DWORD PTR _four$36[ebp]
  00302	0f 85 40 03 00
	00		 jne	 $LN15@main

; 46   : 
; 47   : 					for (int i = 0; i < birthday.size(); i++) {

  00308	c7 85 44 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$15[ebp], 0
  00312	eb 0f		 jmp	 SHORT $LN10@main
$LN8@main:
  00314	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _i$15[ebp]
  0031a	83 c0 01	 add	 eax, 1
  0031d	89 85 44 fe ff
	ff		 mov	 DWORD PTR _i$15[ebp], eax
$LN10@main:
  00323	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _birthday$25[ebp]
  00329	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0032e	39 85 44 fe ff
	ff		 cmp	 DWORD PTR _i$15[ebp], eax
  00334	73 75		 jae	 SHORT $LN9@main

; 48   : 						if ((birthday[i] > '9') || (birthday[i] < '0')) {

  00336	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _i$15[ebp]
  0033c	50		 push	 eax
  0033d	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _birthday$25[ebp]
  00343	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00348	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0034b	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0034e	7f 1a		 jg	 SHORT $LN18@main
  00350	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _i$15[ebp]
  00356	50		 push	 eax
  00357	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _birthday$25[ebp]
  0035d	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00362	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00365	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00368	7d 3c		 jge	 SHORT $LN17@main
$LN18@main:

; 49   : 							cout << "вы ввели неправильную дату" << endl;

  0036a	8b f4		 mov	 esi, esp
  0036c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00371	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@
  00376	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00381	83 c4 08	 add	 esp, 8
  00384	8b c8		 mov	 ecx, eax
  00386	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0038c	3b f4		 cmp	 esi, esp
  0038e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 50   : 							exit(0);

  00393	8b f4		 mov	 esi, esp
  00395	6a 00		 push	 0
  00397	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0039d	3b f4		 cmp	 esi, esp
  0039f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 51   : 							break;

  003a4	eb 05		 jmp	 SHORT $LN9@main
$LN17@main:

; 52   : 						}
; 53   : 					}

  003a6	e9 69 ff ff ff	 jmp	 $LN8@main
$LN9@main:

; 54   : 
; 55   : 					string days_of_birthday(birthday, 0, 2);

  003ab	8d 8d fb fb ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003b1	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  003b6	50		 push	 eax
  003b7	6a 02		 push	 2
  003b9	6a 00		 push	 0
  003bb	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _birthday$25[ebp]
  003c1	50		 push	 eax
  003c2	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _days_of_birthday$14[ebp]
  003c8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003cd	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 56   : 					string monthes_of_birthday(birthday, 2, 2);

  003d1	8d 8d ef fb ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  003d7	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  003dc	50		 push	 eax
  003dd	6a 02		 push	 2
  003df	6a 02		 push	 2
  003e1	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _birthday$25[ebp]
  003e7	50		 push	 eax
  003e8	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _monthes_of_birthday$13[ebp]
  003ee	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003f3	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 57   : 					string expception_birthday(birthday, 0, 4);

  003f7	8d 8d e3 fb ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  003fd	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00402	50		 push	 eax
  00403	6a 04		 push	 4
  00405	6a 00		 push	 0
  00407	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _birthday$25[ebp]
  0040d	50		 push	 eax
  0040e	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _expception_birthday$12[ebp]
  00414	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00419	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8

; 58   : 
; 59   : 					int day_of_birthday = stoi(days_of_birthday);

  0041d	6a 0a		 push	 10			; 0000000aH
  0041f	6a 00		 push	 0
  00421	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _days_of_birthday$14[ebp]
  00427	50		 push	 eax
  00428	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  0042d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00430	89 85 cc fd ff
	ff		 mov	 DWORD PTR _day_of_birthday$11[ebp], eax

; 60   : 					int month_of_birthday = stoi(monthes_of_birthday);

  00436	6a 0a		 push	 10			; 0000000aH
  00438	6a 00		 push	 0
  0043a	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _monthes_of_birthday$13[ebp]
  00440	50		 push	 eax
  00441	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  00446	83 c4 0c	 add	 esp, 12			; 0000000cH
  00449	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _month_of_birthday$10[ebp], eax

; 61   : 					int expceptions_birthday = stoi(expception_birthday);

  0044f	6a 0a		 push	 10			; 0000000aH
  00451	6a 00		 push	 0
  00453	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _expception_birthday$12[ebp]
  00459	50		 push	 eax
  0045a	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  0045f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00462	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _expceptions_birthday$9[ebp], eax

; 62   : 
; 63   : 					if (day < zero || day > thirty_one || month < zero || month > TWELVE || year < zero || day_of_birthday < zero || day_of_birthday > thirty_one || month_of_birthday < zero || month_of_birthday > TWELVE || (expceptions_birthday == 3002) || (expceptions_birthday == 3102) || (exceptions == 3002) || (exceptions == 3102)) {

  00468	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _day$19[ebp]
  0046e	3b 45 a0	 cmp	 eax, DWORD PTR _zero$32[ebp]
  00471	0f 8c 84 00 00
	00		 jl	 $LN21@main
  00477	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _day$19[ebp]
  0047d	3b 45 88	 cmp	 eax, DWORD PTR _thirty_one$30[ebp]
  00480	7f 79		 jg	 SHORT $LN21@main
  00482	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _month$18[ebp]
  00488	3b 45 a0	 cmp	 eax, DWORD PTR _zero$32[ebp]
  0048b	7c 6e		 jl	 SHORT $LN21@main
  0048d	83 bd 68 fe ff
	ff 0c		 cmp	 DWORD PTR _month$18[ebp], 12 ; 0000000cH
  00494	7f 65		 jg	 SHORT $LN21@main
  00496	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _year$17[ebp]
  0049c	3b 45 a0	 cmp	 eax, DWORD PTR _zero$32[ebp]
  0049f	7c 5a		 jl	 SHORT $LN21@main
  004a1	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _day_of_birthday$11[ebp]
  004a7	3b 45 a0	 cmp	 eax, DWORD PTR _zero$32[ebp]
  004aa	7c 4f		 jl	 SHORT $LN21@main
  004ac	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _day_of_birthday$11[ebp]
  004b2	3b 45 88	 cmp	 eax, DWORD PTR _thirty_one$30[ebp]
  004b5	7f 44		 jg	 SHORT $LN21@main
  004b7	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _month_of_birthday$10[ebp]
  004bd	3b 45 a0	 cmp	 eax, DWORD PTR _zero$32[ebp]
  004c0	7c 39		 jl	 SHORT $LN21@main
  004c2	83 bd c0 fd ff
	ff 0c		 cmp	 DWORD PTR _month_of_birthday$10[ebp], 12 ; 0000000cH
  004c9	7f 30		 jg	 SHORT $LN21@main
  004cb	81 bd b4 fd ff
	ff ba 0b 00 00	 cmp	 DWORD PTR _expceptions_birthday$9[ebp], 3002 ; 00000bbaH
  004d5	74 24		 je	 SHORT $LN21@main
  004d7	81 bd b4 fd ff
	ff 1e 0c 00 00	 cmp	 DWORD PTR _expceptions_birthday$9[ebp], 3102 ; 00000c1eH
  004e1	74 18		 je	 SHORT $LN21@main
  004e3	81 bd 50 fe ff
	ff ba 0b 00 00	 cmp	 DWORD PTR _exceptions$16[ebp], 3002 ; 00000bbaH
  004ed	74 0c		 je	 SHORT $LN21@main
  004ef	81 bd 50 fe ff
	ff 1e 0c 00 00	 cmp	 DWORD PTR _exceptions$16[ebp], 3102 ; 00000c1eH
  004f9	75 2e		 jne	 SHORT $LN19@main
$LN21@main:

; 64   : 						cout << "вы ввели неправильную дату" << endl;

  004fb	8b f4		 mov	 esi, esp
  004fd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00502	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@
  00507	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0050c	50		 push	 eax
  0050d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00512	83 c4 08	 add	 esp, 8
  00515	8b c8		 mov	 ecx, eax
  00517	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0051d	3b f4		 cmp	 esi, esp
  0051f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 65   : 					}

  00524	e9 f0 00 00 00	 jmp	 $LN20@main
$LN19@main:

; 66   : 					else {
; 67   : 
; 68   : 						result = findDayAndMonth(day, month);

  00529	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _month$18[ebp]
  0052f	50		 push	 eax
  00530	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _day$19[ebp]
  00536	51		 push	 ecx
  00537	e8 00 00 00 00	 call	 ?findDayAndMonth@@YAHHHZZ ; findDayAndMonth
  0053c	83 c4 08	 add	 esp, 8
  0053f	89 85 7c ff ff
	ff		 mov	 DWORD PTR _result$29[ebp], eax

; 69   : 
; 70   : 						result_of_birthday = findDayAndMonth(day_of_birthday, month_of_birthday);

  00545	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _month_of_birthday$10[ebp]
  0054b	50		 push	 eax
  0054c	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _day_of_birthday$11[ebp]
  00552	51		 push	 ecx
  00553	e8 00 00 00 00	 call	 ?findDayAndMonth@@YAHHHZZ ; findDayAndMonth
  00558	83 c4 08	 add	 esp, 8
  0055b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _result_of_birthday$28[ebp], eax

; 71   : 
; 72   : 						result_of_birthday = getParameters(year, result, result_of_birthday, month, month_of_birthday, day, day_of_birthday);

  00561	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _day_of_birthday$11[ebp]
  00567	50		 push	 eax
  00568	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _day$19[ebp]
  0056e	51		 push	 ecx
  0056f	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _month_of_birthday$10[ebp]
  00575	52		 push	 edx
  00576	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _month$18[ebp]
  0057c	50		 push	 eax
  0057d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _result_of_birthday$28[ebp]
  00583	51		 push	 ecx
  00584	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _result$29[ebp]
  0058a	52		 push	 edx
  0058b	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _year$17[ebp]
  00591	50		 push	 eax
  00592	e8 00 00 00 00	 call	 ?getParameters@@YAHHHHHHHH@Z ; getParameters
  00597	83 c4 1c	 add	 esp, 28			; 0000001cH
  0059a	89 85 70 ff ff
	ff		 mov	 DWORD PTR _result_of_birthday$28[ebp], eax

; 73   : 						cout << result_of_birthday;

  005a0	8b f4		 mov	 esi, esp
  005a2	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _result_of_birthday$28[ebp]
  005a8	50		 push	 eax
  005a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  005b5	3b f4		 cmp	 esi, esp
  005b7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 74   : 
; 75   : 						quantity = getAnswer(result, result_of_birthday, day, day_of_birthday, year);

  005bc	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _year$17[ebp]
  005c2	50		 push	 eax
  005c3	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _day_of_birthday$11[ebp]
  005c9	51		 push	 ecx
  005ca	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR _day$19[ebp]
  005d0	52		 push	 edx
  005d1	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _result_of_birthday$28[ebp]
  005d7	50		 push	 eax
  005d8	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _result$29[ebp]
  005de	51		 push	 ecx
  005df	e8 00 00 00 00	 call	 ?getAnswer@@YAHHHHHH@Z	; getAnswer
  005e4	83 c4 14	 add	 esp, 20			; 00000014H
  005e7	89 85 64 ff ff
	ff		 mov	 DWORD PTR _quantity$27[ebp], eax

; 76   : 						cout << "\nрезультат = " << quantity;

  005ed	8b f4		 mov	 esi, esp
  005ef	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _quantity$27[ebp]
  005f5	50		 push	 eax
  005f6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNFNCAFF@?6?p?e?g?s?k?$PM?r?$OA?r?5?$DN?5@
  005fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00601	51		 push	 ecx
  00602	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00607	83 c4 08	 add	 esp, 8
  0060a	8b c8		 mov	 ecx, eax
  0060c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00612	3b f4		 cmp	 esi, esp
  00614	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@main:

; 77   : 					}
; 78   : 				}

  00619	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0061d	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _expception_birthday$12[ebp]
  00623	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00628	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0062c	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _monthes_of_birthday$13[ebp]
  00632	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00637	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0063b	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _days_of_birthday$14[ebp]
  00641	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00646	eb 29		 jmp	 SHORT $LN16@main
$LN15@main:

; 79   : 				else {
; 80   : 					cout << "вы ввели неправильную дату" << endl;

  00648	8b f4		 mov	 esi, esp
  0064a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0064f	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@
  00654	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00659	50		 push	 eax
  0065a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0065f	83 c4 08	 add	 esp, 8
  00662	8b c8		 mov	 ecx, eax
  00664	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0066a	3b f4		 cmp	 esi, esp
  0066c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@main:

; 81   : 				}
; 82   : 			}

  00671	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00675	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _exception$20[ebp]
  0067b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00680	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00684	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _years$21[ebp]
  0068a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0068f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00693	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _monthes$22[ebp]
  00699	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0069e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  006a2	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _days$23[ebp]
  006a8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  006ad	eb 29		 jmp	 SHORT $LN14@main
$LN13@main:

; 83   : 		else {
; 84   : 			cout << "вы ввели неправильную дату" << endl;

  006af	8b f4		 mov	 esi, esp
  006b1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KJLIPDAC@?b?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?s?$PO?5?d?$OA?r?s@
  006bb	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006c0	50		 push	 eax
  006c1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006c6	83 c4 08	 add	 esp, 8
  006c9	8b c8		 mov	 ecx, eax
  006cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  006d1	3b f4		 cmp	 esi, esp
  006d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@main:

; 85   : 		}
; 86   : 		cout << "\nвведите 1, чтобы продолжить, 2, чтобы закончить:" << endl;

  006d8	8b f4		 mov	 esi, esp
  006da	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006df	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@FIDMDLFP@?6?b?b?e?d?h?r?e?51?0?5?w?r?n?a?$PL?5?o?p?n?d?n?k?f?h?r?$PM?0?52@
  006e4	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006e9	50		 push	 eax
  006ea	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006ef	83 c4 08	 add	 esp, 8
  006f2	8b c8		 mov	 ecx, eax
  006f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  006fa	3b f4		 cmp	 esi, esp
  006fc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 87   : 		cin >> c;

  00701	8b f4		 mov	 esi, esp
  00703	8d 45 e8	 lea	 eax, DWORD PTR _c$[ebp]
  00706	50		 push	 eax
  00707	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  0070d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
  00713	3b f4		 cmp	 esi, esp
  00715	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 88   : 		}

  0071a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0071e	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _birthday$25[ebp]
  00724	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00729	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00730	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _date$26[ebp]
  00736	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 89   : 	 while (c != 2);

  0073b	83 7d e8 02	 cmp	 DWORD PTR _c$[ebp], 2
  0073f	0f 85 25 f9 ff
	ff		 jne	 $LN4@main

; 90   : 	}

  00745	eb 02		 jmp	 SHORT $LN33@main
$LN22@main:
  00747	eb 02		 jmp	 SHORT $LN32@main
$LN33@main:
  00749	33 c0		 xor	 eax, eax
$LN32@main:
  0074b	52		 push	 edx
  0074c	8b cd		 mov	 ecx, ebp
  0074e	50		 push	 eax
  0074f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN46@main
  00755	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0075a	58		 pop	 eax
  0075b	5a		 pop	 edx
  0075c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0075f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00766	59		 pop	 ecx
  00767	5f		 pop	 edi
  00768	5e		 pop	 esi
  00769	5b		 pop	 ebx
  0076a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0076d	33 cd		 xor	 ecx, ebp
  0076f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00774	81 c4 24 04 00
	00		 add	 esp, 1060		; 00000424H
  0077a	3b ec		 cmp	 ebp, esp
  0077c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00781	8b e5		 mov	 esp, ebp
  00783	5d		 pop	 ebp
  00784	c3		 ret	 0
  00785	0f 1f 00	 npad	 3
$LN46@main:
  00788	0a 00 00 00	 DD	 10			; 0000000aH
  0078c	00 00 00 00	 DD	 $LN45@main
$LN45@main:
  00790	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00794	04 00 00 00	 DD	 4
  00798	00 00 00 00	 DD	 $LN34@main
  0079c	40 ff ff ff	 DD	 -192			; ffffff40H
  007a0	1c 00 00 00	 DD	 28			; 0000001cH
  007a4	00 00 00 00	 DD	 $LN35@main
  007a8	1c ff ff ff	 DD	 -228			; ffffff1cH
  007ac	1c 00 00 00	 DD	 28			; 0000001cH
  007b0	00 00 00 00	 DD	 $LN36@main
  007b4	ec fe ff ff	 DD	 -276			; fffffeecH
  007b8	1c 00 00 00	 DD	 28			; 0000001cH
  007bc	00 00 00 00	 DD	 $LN37@main
  007c0	c8 fe ff ff	 DD	 -312			; fffffec8H
  007c4	1c 00 00 00	 DD	 28			; 0000001cH
  007c8	00 00 00 00	 DD	 $LN38@main
  007cc	a4 fe ff ff	 DD	 -348			; fffffea4H
  007d0	1c 00 00 00	 DD	 28			; 0000001cH
  007d4	00 00 00 00	 DD	 $LN39@main
  007d8	80 fe ff ff	 DD	 -384			; fffffe80H
  007dc	1c 00 00 00	 DD	 28			; 0000001cH
  007e0	00 00 00 00	 DD	 $LN40@main
  007e4	20 fe ff ff	 DD	 -480			; fffffe20H
  007e8	1c 00 00 00	 DD	 28			; 0000001cH
  007ec	00 00 00 00	 DD	 $LN41@main
  007f0	fc fd ff ff	 DD	 -516			; fffffdfcH
  007f4	1c 00 00 00	 DD	 28			; 0000001cH
  007f8	00 00 00 00	 DD	 $LN42@main
  007fc	d8 fd ff ff	 DD	 -552			; fffffdd8H
  00800	1c 00 00 00	 DD	 28			; 0000001cH
  00804	00 00 00 00	 DD	 $LN43@main
$LN43@main:
  00808	65		 DB	 101			; 00000065H
  00809	78		 DB	 120			; 00000078H
  0080a	70		 DB	 112			; 00000070H
  0080b	63		 DB	 99			; 00000063H
  0080c	65		 DB	 101			; 00000065H
  0080d	70		 DB	 112			; 00000070H
  0080e	74		 DB	 116			; 00000074H
  0080f	69		 DB	 105			; 00000069H
  00810	6f		 DB	 111			; 0000006fH
  00811	6e		 DB	 110			; 0000006eH
  00812	5f		 DB	 95			; 0000005fH
  00813	62		 DB	 98			; 00000062H
  00814	69		 DB	 105			; 00000069H
  00815	72		 DB	 114			; 00000072H
  00816	74		 DB	 116			; 00000074H
  00817	68		 DB	 104			; 00000068H
  00818	64		 DB	 100			; 00000064H
  00819	61		 DB	 97			; 00000061H
  0081a	79		 DB	 121			; 00000079H
  0081b	00		 DB	 0
$LN42@main:
  0081c	6d		 DB	 109			; 0000006dH
  0081d	6f		 DB	 111			; 0000006fH
  0081e	6e		 DB	 110			; 0000006eH
  0081f	74		 DB	 116			; 00000074H
  00820	68		 DB	 104			; 00000068H
  00821	65		 DB	 101			; 00000065H
  00822	73		 DB	 115			; 00000073H
  00823	5f		 DB	 95			; 0000005fH
  00824	6f		 DB	 111			; 0000006fH
  00825	66		 DB	 102			; 00000066H
  00826	5f		 DB	 95			; 0000005fH
  00827	62		 DB	 98			; 00000062H
  00828	69		 DB	 105			; 00000069H
  00829	72		 DB	 114			; 00000072H
  0082a	74		 DB	 116			; 00000074H
  0082b	68		 DB	 104			; 00000068H
  0082c	64		 DB	 100			; 00000064H
  0082d	61		 DB	 97			; 00000061H
  0082e	79		 DB	 121			; 00000079H
  0082f	00		 DB	 0
$LN41@main:
  00830	64		 DB	 100			; 00000064H
  00831	61		 DB	 97			; 00000061H
  00832	79		 DB	 121			; 00000079H
  00833	73		 DB	 115			; 00000073H
  00834	5f		 DB	 95			; 0000005fH
  00835	6f		 DB	 111			; 0000006fH
  00836	66		 DB	 102			; 00000066H
  00837	5f		 DB	 95			; 0000005fH
  00838	62		 DB	 98			; 00000062H
  00839	69		 DB	 105			; 00000069H
  0083a	72		 DB	 114			; 00000072H
  0083b	74		 DB	 116			; 00000074H
  0083c	68		 DB	 104			; 00000068H
  0083d	64		 DB	 100			; 00000064H
  0083e	61		 DB	 97			; 00000061H
  0083f	79		 DB	 121			; 00000079H
  00840	00		 DB	 0
$LN40@main:
  00841	65		 DB	 101			; 00000065H
  00842	78		 DB	 120			; 00000078H
  00843	63		 DB	 99			; 00000063H
  00844	65		 DB	 101			; 00000065H
  00845	70		 DB	 112			; 00000070H
  00846	74		 DB	 116			; 00000074H
  00847	69		 DB	 105			; 00000069H
  00848	6f		 DB	 111			; 0000006fH
  00849	6e		 DB	 110			; 0000006eH
  0084a	00		 DB	 0
$LN39@main:
  0084b	79		 DB	 121			; 00000079H
  0084c	65		 DB	 101			; 00000065H
  0084d	61		 DB	 97			; 00000061H
  0084e	72		 DB	 114			; 00000072H
  0084f	73		 DB	 115			; 00000073H
  00850	00		 DB	 0
$LN38@main:
  00851	6d		 DB	 109			; 0000006dH
  00852	6f		 DB	 111			; 0000006fH
  00853	6e		 DB	 110			; 0000006eH
  00854	74		 DB	 116			; 00000074H
  00855	68		 DB	 104			; 00000068H
  00856	65		 DB	 101			; 00000065H
  00857	73		 DB	 115			; 00000073H
  00858	00		 DB	 0
$LN37@main:
  00859	64		 DB	 100			; 00000064H
  0085a	61		 DB	 97			; 00000061H
  0085b	79		 DB	 121			; 00000079H
  0085c	73		 DB	 115			; 00000073H
  0085d	00		 DB	 0
$LN36@main:
  0085e	62		 DB	 98			; 00000062H
  0085f	69		 DB	 105			; 00000069H
  00860	72		 DB	 114			; 00000072H
  00861	74		 DB	 116			; 00000074H
  00862	68		 DB	 104			; 00000068H
  00863	64		 DB	 100			; 00000064H
  00864	61		 DB	 97			; 00000061H
  00865	79		 DB	 121			; 00000079H
  00866	00		 DB	 0
$LN35@main:
  00867	64		 DB	 100			; 00000064H
  00868	61		 DB	 97			; 00000061H
  00869	74		 DB	 116			; 00000074H
  0086a	65		 DB	 101			; 00000065H
  0086b	00		 DB	 0
$LN34@main:
  0086c	63		 DB	 99			; 00000063H
  0086d	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _date$26[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$1:
  0000b	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _birthday$25[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$2:
  00016	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _days$23[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$3:
  00021	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _monthes$22[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$4:
  0002c	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _years$21[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$5:
  00037	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _exception$20[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$6:
  00042	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _days_of_birthday$14[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$7:
  0004d	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _monthes_of_birthday$13[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$8:
  00058	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _expception_birthday$12[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
__ehhandler$_main:
  00068	90		 npad	 1
  00069	90		 npad	 1
  0006a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0006e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00071	8b 8a d8 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1064]
  00077	33 c8		 xor	 ecx, eax
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00081	33 c8		 xor	 ecx, eax
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  0008d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\лабы\2 семестр\кпо\лаб.1\dates\dates\answer.cpp
;	COMDAT ?getAnswer@@YAHHHHHH@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_number$ = -8						; size = 4
_result$ = 8						; size = 4
_result_of_birthday$ = 12				; size = 4
_day$ = 16						; size = 4
_day_of_birthday$ = 20					; size = 4
_year$ = 24						; size = 4
?getAnswer@@YAHHHHHH@Z PROC				; getAnswer, COMDAT

; 5    : static int getAnswer(int result, int result_of_birthday, int day, int day_of_birthday, int year) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0000f	b9 06 00 00 00	 mov	 ecx, 6
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __67153995_answer@cpp
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6    : 
; 7    : 	int number;
; 8    : 
; 9    : 	if ((result > result_of_birthday) && (year % 4 == 0) && ((year + 1) % 100 != 0) && ((year + 1) % 4 != 0)) {

  0002c	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  0002f	3b 45 0c	 cmp	 eax, DWORD PTR _result_of_birthday$[ebp]
  00032	7e 55		 jle	 SHORT $LN2@getAnswer
  00034	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  00037	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0003c	79 05		 jns	 SHORT $LN17@getAnswer
  0003e	48		 dec	 eax
  0003f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00042	40		 inc	 eax
$LN17@getAnswer:
  00043	85 c0		 test	 eax, eax
  00045	75 42		 jne	 SHORT $LN2@getAnswer
  00047	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	99		 cdq
  0004e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00053	f7 f9		 idiv	 ecx
  00055	85 d2		 test	 edx, edx
  00057	74 30		 je	 SHORT $LN2@getAnswer
  00059	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00064	79 05		 jns	 SHORT $LN18@getAnswer
  00066	48		 dec	 eax
  00067	83 c8 fc	 or	 eax, -4			; fffffffcH
  0006a	40		 inc	 eax
$LN18@getAnswer:
  0006b	85 c0		 test	 eax, eax
  0006d	74 1a		 je	 SHORT $LN2@getAnswer

; 10   : 		number = 366 + 1 - result + result_of_birthday;

  0006f	b8 6f 01 00 00	 mov	 eax, 367		; 0000016fH
  00074	2b 45 08	 sub	 eax, DWORD PTR _result$[ebp]
  00077	03 45 0c	 add	 eax, DWORD PTR _result_of_birthday$[ebp]
  0007a	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  00081	89 45 f8	 mov	 DWORD PTR _number$[ebp], eax

; 11   : 	}

  00084	e9 17 01 00 00	 jmp	 $LN12@getAnswer
$LN2@getAnswer:

; 12   : 	else if ((result > result_of_birthday) && (year % 4 != 0 || year % 400 != 0) && ((year + 1) % 100 != 0) && ((year + 1) % 4 == 0 || (year + 1) % 400 == 0)) {

  00089	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  0008c	3b 45 0c	 cmp	 eax, DWORD PTR _result_of_birthday$[ebp]
  0008f	7e 76		 jle	 SHORT $LN4@getAnswer
  00091	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  00094	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00099	79 05		 jns	 SHORT $LN19@getAnswer
  0009b	48		 dec	 eax
  0009c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0009f	40		 inc	 eax
$LN19@getAnswer:
  000a0	85 c0		 test	 eax, eax
  000a2	75 0f		 jne	 SHORT $LN6@getAnswer
  000a4	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  000a7	99		 cdq
  000a8	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  000ad	f7 f9		 idiv	 ecx
  000af	85 d2		 test	 edx, edx
  000b1	74 54		 je	 SHORT $LN4@getAnswer
$LN6@getAnswer:
  000b3	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  000b6	83 c0 01	 add	 eax, 1
  000b9	99		 cdq
  000ba	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000bf	f7 f9		 idiv	 ecx
  000c1	85 d2		 test	 edx, edx
  000c3	74 42		 je	 SHORT $LN4@getAnswer
  000c5	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  000c8	83 c0 01	 add	 eax, 1
  000cb	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000d0	79 05		 jns	 SHORT $LN20@getAnswer
  000d2	48		 dec	 eax
  000d3	83 c8 fc	 or	 eax, -4			; fffffffcH
  000d6	40		 inc	 eax
$LN20@getAnswer:
  000d7	85 c0		 test	 eax, eax
  000d9	74 12		 je	 SHORT $LN7@getAnswer
  000db	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  000de	83 c0 01	 add	 eax, 1
  000e1	99		 cdq
  000e2	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  000e7	f7 f9		 idiv	 ecx
  000e9	85 d2		 test	 edx, edx
  000eb	75 1a		 jne	 SHORT $LN4@getAnswer
$LN7@getAnswer:

; 13   : 		number = 365 + 2 - result + result_of_birthday;

  000ed	b8 6f 01 00 00	 mov	 eax, 367		; 0000016fH
  000f2	2b 45 08	 sub	 eax, DWORD PTR _result$[ebp]
  000f5	03 45 0c	 add	 eax, DWORD PTR _result_of_birthday$[ebp]
  000f8	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  000ff	89 45 f8	 mov	 DWORD PTR _number$[ebp], eax

; 14   : 	}

  00102	e9 99 00 00 00	 jmp	 $LN12@getAnswer
$LN4@getAnswer:

; 15   : 	else if ((result > result_of_birthday) && (year % 4 != 0 || year % 400 != 0) && ((year + 1) % 100 != 0) && ((year + 1) % 4 != 0 || (year + 1) % 400 != 0)) {

  00107	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  0010a	3b 45 0c	 cmp	 eax, DWORD PTR _result_of_birthday$[ebp]
  0010d	7e 73		 jle	 SHORT $LN8@getAnswer
  0010f	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  00112	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00117	79 05		 jns	 SHORT $LN21@getAnswer
  00119	48		 dec	 eax
  0011a	83 c8 fc	 or	 eax, -4			; fffffffcH
  0011d	40		 inc	 eax
$LN21@getAnswer:
  0011e	85 c0		 test	 eax, eax
  00120	75 0f		 jne	 SHORT $LN10@getAnswer
  00122	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  00125	99		 cdq
  00126	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  0012b	f7 f9		 idiv	 ecx
  0012d	85 d2		 test	 edx, edx
  0012f	74 51		 je	 SHORT $LN8@getAnswer
$LN10@getAnswer:
  00131	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  00134	83 c0 01	 add	 eax, 1
  00137	99		 cdq
  00138	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0013d	f7 f9		 idiv	 ecx
  0013f	85 d2		 test	 edx, edx
  00141	74 3f		 je	 SHORT $LN8@getAnswer
  00143	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  00146	83 c0 01	 add	 eax, 1
  00149	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0014e	79 05		 jns	 SHORT $LN22@getAnswer
  00150	48		 dec	 eax
  00151	83 c8 fc	 or	 eax, -4			; fffffffcH
  00154	40		 inc	 eax
$LN22@getAnswer:
  00155	85 c0		 test	 eax, eax
  00157	75 12		 jne	 SHORT $LN11@getAnswer
  00159	8b 45 18	 mov	 eax, DWORD PTR _year$[ebp]
  0015c	83 c0 01	 add	 eax, 1
  0015f	99		 cdq
  00160	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  00165	f7 f9		 idiv	 ecx
  00167	85 d2		 test	 edx, edx
  00169	74 17		 je	 SHORT $LN8@getAnswer
$LN11@getAnswer:

; 16   : 		number = 365 + 2 - result + result_of_birthday;

  0016b	b8 6f 01 00 00	 mov	 eax, 367		; 0000016fH
  00170	2b 45 08	 sub	 eax, DWORD PTR _result$[ebp]
  00173	03 45 0c	 add	 eax, DWORD PTR _result_of_birthday$[ebp]
  00176	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  0017d	89 45 f8	 mov	 DWORD PTR _number$[ebp], eax

; 17   : 	}

  00180	eb 1e		 jmp	 SHORT $LN12@getAnswer
$LN8@getAnswer:

; 18   : 	else if (result <= (result_of_birthday + 1)) {

  00182	8b 45 0c	 mov	 eax, DWORD PTR _result_of_birthday$[ebp]
  00185	83 c0 01	 add	 eax, 1
  00188	39 45 08	 cmp	 DWORD PTR _result$[ebp], eax
  0018b	7f 13		 jg	 SHORT $LN12@getAnswer

; 19   : 		number = result_of_birthday - result + 1;

  0018d	8b 45 0c	 mov	 eax, DWORD PTR _result_of_birthday$[ebp]
  00190	2b 45 08	 sub	 eax, DWORD PTR _result$[ebp]
  00193	83 c0 01	 add	 eax, 1
  00196	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  0019d	89 45 f8	 mov	 DWORD PTR _number$[ebp], eax
$LN12@getAnswer:

; 20   : 	}
; 21   : 
; 22   : 	return number;

  001a0	80 bd 2f ff ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  001a7	75 0d		 jne	 SHORT $LN14@getAnswer
  001a9	68 00 00 00 00	 push	 OFFSET $LN15@getAnswer
  001ae	e8 00 00 00 00	 call	 __RTC_UninitUse
  001b3	83 c4 04	 add	 esp, 4
$LN14@getAnswer:
  001b6	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]

; 23   : }

  001b9	5f		 pop	 edi
  001ba	5e		 pop	 esi
  001bb	5b		 pop	 ebx
  001bc	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001c2	3b ec		 cmp	 ebp, esp
  001c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
$LN16@getAnswer:
$LN15@getAnswer:
  001cd	6e		 DB	 110			; 0000006eH
  001ce	75		 DB	 117			; 00000075H
  001cf	6d		 DB	 109			; 0000006dH
  001d0	62		 DB	 98			; 00000062H
  001d1	65		 DB	 101			; 00000065H
  001d2	72		 DB	 114			; 00000072H
  001d3	00		 DB	 0
?getAnswer@@YAHHHHHH@Z ENDP				; getAnswer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\лабы\2 семестр\кпо\лаб.1\dates\dates\parameters.cpp
;	COMDAT ?getParameters@@YAHHHHHHHH@Z
_TEXT	SEGMENT
_score_of_birthday$ = -44				; size = 4
_score_of_date$ = -32					; size = 4
_fourhungreed$ = -20					; size = 4
_four$ = -8						; size = 4
_year$ = 8						; size = 4
_result$ = 12						; size = 4
_result_of_birthday$ = 16				; size = 4
_month$ = 20						; size = 4
_month_of_birthday$ = 24				; size = 4
_day$ = 28						; size = 4
_day_of_birthday$ = 32					; size = 4
?getParameters@@YAHHHHHHHH@Z PROC			; getParameters, COMDAT

; 6    : static int getParameters(int year, int result, int result_of_birthday, int month, int month_of_birthday, int day, int day_of_birthday) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __47025CB3_parameters@cpp
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7    : 
; 8    : 	int four = 4, fourhungreed = 400, score_of_date = 0, score_of_birthday = 0;

  00025	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _four$[ebp], 4
  0002c	c7 45 ec 90 01
	00 00		 mov	 DWORD PTR _fourhungreed$[ebp], 400 ; 00000190H
  00033	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _score_of_date$[ebp], 0
  0003a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _score_of_birthday$[ebp], 0

; 9    : 
; 10   : 	if ((year % four == 0) || (year % fourhungreed == 0)) {

  00041	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  00044	99		 cdq
  00045	f7 7d f8	 idiv	 DWORD PTR _four$[ebp]
  00048	85 d2		 test	 edx, edx
  0004a	74 0b		 je	 SHORT $LN4@getParamet
  0004c	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  0004f	99		 cdq
  00050	f7 7d ec	 idiv	 DWORD PTR _fourhungreed$[ebp]
  00053	85 d2		 test	 edx, edx
  00055	75 79		 jne	 SHORT $LN2@getParamet
$LN4@getParamet:

; 11   : 		cout << "год високосный:" << endl;

  00057	8b f4		 mov	 esi, esp
  00059	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LCFMICKJ@?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?3@
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0006e	83 c4 08	 add	 esp, 8
  00071	8b c8		 mov	 ecx, eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00079	3b f4		 cmp	 esi, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 12   : 		cout << result << endl;

  00080	8b f4		 mov	 esi, esp
  00082	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00087	8b fc		 mov	 edi, esp
  00089	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0008c	50		 push	 eax
  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00099	3b fc		 cmp	 edi, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b c8		 mov	 ecx, eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 13   : 		getParametersOfBirthday(year, month, month_of_birthday, day, day_of_birthday);

  000af	8b 45 20	 mov	 eax, DWORD PTR _day_of_birthday$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d 1c	 mov	 ecx, DWORD PTR _day$[ebp]
  000b6	51		 push	 ecx
  000b7	8b 55 18	 mov	 edx, DWORD PTR _month_of_birthday$[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 14	 mov	 eax, DWORD PTR _month$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _year$[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ?getParametersOfBirthday@@YAXHHHHH@Z ; getParametersOfBirthday
  000c8	83 c4 14	 add	 esp, 20			; 00000014H

; 14   : 
; 15   : 
; 16   : 	}

  000cb	e9 56 01 00 00	 jmp	 $LN6@getParamet
$LN2@getParamet:

; 17   : 	else if (year % 100 == 0) {

  000d0	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  000d3	99		 cdq
  000d4	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000d9	f7 f9		 idiv	 ecx
  000db	85 d2		 test	 edx, edx
  000dd	0f 85 9d 00 00
	00		 jne	 $LN5@getParamet

; 18   : 		cout << "год невисокосный:" << endl;

  000e3	8b f4		 mov	 esi, esp
  000e5	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CIPPACFL@?c?n?d?5?m?e?b?h?q?n?j?n?q?m?$PL?i?3@
  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000fa	83 c4 08	 add	 esp, 8
  000fd	8b c8		 mov	 ecx, eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00105	3b f4		 cmp	 esi, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 19   : 		if ((year + 1) % 100 == 0) {

  0010c	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  0010f	83 c0 01	 add	 eax, 1
  00112	99		 cdq
  00113	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00118	f7 f9		 idiv	 ecx
  0011a	85 d2		 test	 edx, edx
  0011c	75 09		 jne	 SHORT $LN7@getParamet

; 20   : 			result_of_birthday -= 1;

  0011e	8b 45 10	 mov	 eax, DWORD PTR _result_of_birthday$[ebp]
  00121	83 e8 01	 sub	 eax, 1
  00124	89 45 10	 mov	 DWORD PTR _result_of_birthday$[ebp], eax
$LN7@getParamet:

; 21   : 
; 22   : 		}
; 23   : 
; 24   : 		result -= 1;

  00127	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0012a	83 e8 01	 sub	 eax, 1
  0012d	89 45 0c	 mov	 DWORD PTR _result$[ebp], eax

; 25   : 
; 26   : 		cout << result << endl;

  00130	8b f4		 mov	 esi, esp
  00132	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00137	8b fc		 mov	 edi, esp
  00139	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  0013c	50		 push	 eax
  0013d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00149	3b fc		 cmp	 edi, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b c8		 mov	 ecx, eax
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00158	3b f4		 cmp	 esi, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 27   : 		getParametersOfBirthday(year, month, month_of_birthday, day, day_of_birthday);

  0015f	8b 45 20	 mov	 eax, DWORD PTR _day_of_birthday$[ebp]
  00162	50		 push	 eax
  00163	8b 4d 1c	 mov	 ecx, DWORD PTR _day$[ebp]
  00166	51		 push	 ecx
  00167	8b 55 18	 mov	 edx, DWORD PTR _month_of_birthday$[ebp]
  0016a	52		 push	 edx
  0016b	8b 45 14	 mov	 eax, DWORD PTR _month$[ebp]
  0016e	50		 push	 eax
  0016f	8b 4d 08	 mov	 ecx, DWORD PTR _year$[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 ?getParametersOfBirthday@@YAXHHHHH@Z ; getParametersOfBirthday
  00178	83 c4 14	 add	 esp, 20			; 00000014H

; 28   : 
; 29   : 
; 30   : 	}

  0017b	e9 a6 00 00 00	 jmp	 $LN6@getParamet
$LN5@getParamet:

; 31   : 	else {
; 32   : 		cout << "год невисокосный:" << endl;

  00180	8b f4		 mov	 esi, esp
  00182	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CIPPACFL@?c?n?d?5?m?e?b?h?q?n?j?n?q?m?$PL?i?3@
  0018c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00197	83 c4 08	 add	 esp, 8
  0019a	8b c8		 mov	 ecx, eax
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  001a2	3b f4		 cmp	 esi, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 33   : 		if ((year + 1) % 100 != 0 || (year + 1) % four != 0) {

  001a9	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  001ac	83 c0 01	 add	 eax, 1
  001af	99		 cdq
  001b0	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001b5	f7 f9		 idiv	 ecx
  001b7	85 d2		 test	 edx, edx
  001b9	75 0e		 jne	 SHORT $LN9@getParamet
  001bb	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  001be	83 c0 01	 add	 eax, 1
  001c1	99		 cdq
  001c2	f7 7d f8	 idiv	 DWORD PTR _four$[ebp]
  001c5	85 d2		 test	 edx, edx
  001c7	74 09		 je	 SHORT $LN8@getParamet
$LN9@getParamet:

; 34   : 			result_of_birthday -= 1;

  001c9	8b 45 10	 mov	 eax, DWORD PTR _result_of_birthday$[ebp]
  001cc	83 e8 01	 sub	 eax, 1
  001cf	89 45 10	 mov	 DWORD PTR _result_of_birthday$[ebp], eax
$LN8@getParamet:

; 35   : 
; 36   : 		}
; 37   : 		result -= 1;

  001d2	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  001d5	83 e8 01	 sub	 eax, 1
  001d8	89 45 0c	 mov	 DWORD PTR _result$[ebp], eax

; 38   : 
; 39   : 		cout << result << endl;

  001db	8b f4		 mov	 esi, esp
  001dd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001e2	8b fc		 mov	 edi, esp
  001e4	8b 45 0c	 mov	 eax, DWORD PTR _result$[ebp]
  001e7	50		 push	 eax
  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  001f4	3b fc		 cmp	 edi, esp
  001f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fb	8b c8		 mov	 ecx, eax
  001fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00203	3b f4		 cmp	 esi, esp
  00205	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 40   : 		getParametersOfBirthday(year, month, month_of_birthday, day, day_of_birthday);

  0020a	8b 45 20	 mov	 eax, DWORD PTR _day_of_birthday$[ebp]
  0020d	50		 push	 eax
  0020e	8b 4d 1c	 mov	 ecx, DWORD PTR _day$[ebp]
  00211	51		 push	 ecx
  00212	8b 55 18	 mov	 edx, DWORD PTR _month_of_birthday$[ebp]
  00215	52		 push	 edx
  00216	8b 45 14	 mov	 eax, DWORD PTR _month$[ebp]
  00219	50		 push	 eax
  0021a	8b 4d 08	 mov	 ecx, DWORD PTR _year$[ebp]
  0021d	51		 push	 ecx
  0021e	e8 00 00 00 00	 call	 ?getParametersOfBirthday@@YAXHHHHH@Z ; getParametersOfBirthday
  00223	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@getParamet:

; 41   : 
; 42   : 	}
; 43   : 	return result_of_birthday;

  00226	8b 45 10	 mov	 eax, DWORD PTR _result_of_birthday$[ebp]

; 44   : }

  00229	5f		 pop	 edi
  0022a	5e		 pop	 esi
  0022b	5b		 pop	 ebx
  0022c	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00232	3b ec		 cmp	 ebp, esp
  00234	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00239	8b e5		 mov	 esp, ebp
  0023b	5d		 pop	 ebp
  0023c	c3		 ret	 0
?getParameters@@YAHHHHHHHH@Z ENDP			; getParameters
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1010 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __FD5AC441_ostream
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1011 :     _Ostr.put(_Ostr.widen('\n'));

  00021	8b f4		 mov	 esi, esp
  00023	6a 0a		 push	 10			; 0000000aH
  00025	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0002d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00030	8b ca		 mov	 ecx, edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b f4		 mov	 esi, esp
  00041	0f b6 c0	 movzx	 eax, al
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1012 :     _Ostr.flush();

  00055	8b f4		 mov	 esi, esp
  00057	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1013 :     return _Ostr;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 1014 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -308						; size = 8
tv337 = -300						; size = 8
tv323 = -292						; size = 8
tv284 = -292						; size = 8
tv285 = -288						; size = 4
tv137 = -288						; size = 4
$T2 = -280						; size = 4
__Ok$ = -76						; size = 8
__Pad$ = -60						; size = 8
__Count$ = -44						; size = 8
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 766  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d 7d 8c	 lea	 edi, DWORD PTR [ebp-116]
  0001e	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET __FD5AC441_ostream
  00046	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 767  :     // insert NTBS into char stream
; 768  :     using _Elem = char;
; 769  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 770  : 
; 771  :     ios_base::iostate _State = ios_base::goodbit;

  0004b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 772  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  00052	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0005b	83 c4 04	 add	 esp, 4
  0005e	33 c9		 xor	 ecx, ecx
  00060	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00063	89 4d d8	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 773  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00066	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00071	8b f4		 mov	 esi, esp
  00073	8b ca		 mov	 ecx, edx
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv323[ebp], eax
  00088	89 95 e0 fe ff
	ff		 mov	 DWORD PTR tv323[ebp+4], edx
  0008e	83 bd e0 fe ff
	ff 00		 cmp	 DWORD PTR tv323[ebp+4], 0
  00095	7c 79		 jl	 SHORT $LN17@operator
  00097	7f 09		 jg	 SHORT $LN24@operator
  00099	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR tv323[ebp], 0
  000a0	76 6e		 jbe	 SHORT $LN17@operator
$LN24@operator:
  000a2	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000aa	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000ad	8b f4		 mov	 esi, esp
  000af	8b ca		 mov	 ecx, edx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv337[ebp], eax
  000c4	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv337[ebp+4], edx
  000ca	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv337[ebp+4]
  000d0	3b 45 d8	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  000d3	7c 3b		 jl	 SHORT $LN17@operator
  000d5	7f 0b		 jg	 SHORT $LN25@operator
  000d7	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv337[ebp]
  000dd	3b 4d d4	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000e0	76 2e		 jbe	 SHORT $LN17@operator
$LN25@operator:
  000e2	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000e5	8b 02		 mov	 eax, DWORD PTR [edx]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000ea	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000ed	8b f4		 mov	 esi, esp
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000f5	3b f4		 cmp	 esi, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fc	2b 45 d4	 sub	 eax, DWORD PTR __Count$[ebp]
  000ff	1b 55 d8	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  00102	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
  00108	89 95 d0 fe ff
	ff		 mov	 DWORD PTR tv135[ebp+4], edx
  0010e	eb 0b		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00110	0f 57 c0	 xorps	 xmm0, xmm0
  00113	66 0f 13 85 cc
	fe ff ff	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  0011b	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv135[ebp]
  00121	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv135[ebp+4]
  00127	89 4d c4	 mov	 DWORD PTR __Pad$[ebp], ecx
  0012a	89 55 c8	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 774  :     const typename _Myos::sentry _Ok(_Ostr);

  0012d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00130	50		 push	 eax
  00131	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00134	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00139	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 775  : 
; 776  :     if (!_Ok) {

  00140	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00143	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00148	0f b6 c0	 movzx	 eax, al
  0014b	85 c0		 test	 eax, eax
  0014d	75 0e		 jne	 SHORT $LN8@operator

; 777  :         _State |= ios_base::badbit;

  0014f	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00152	83 c8 04	 or	 eax, 4
  00155	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 778  :     } else { // state okay, insert

  00158	e9 40 02 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 779  :         _TRY_IO_BEGIN

  0015d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 780  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00161	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00164	8b 08		 mov	 ecx, DWORD PTR [eax]
  00166	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00169	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0016c	8b f4		 mov	 esi, esp
  0016e	8b ca		 mov	 ecx, edx
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00176	3b f4		 cmp	 esi, esp
  00178	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017d	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00182	83 f8 40	 cmp	 eax, 64			; 00000040H
  00185	0f 84 a3 00 00
	00		 je	 $LN3@operator

; 781  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0018b	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0018d	8b 45 c4	 mov	 eax, DWORD PTR __Pad$[ebp]
  00190	83 e8 01	 sub	 eax, 1
  00193	8b 4d c8	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  00196	83 d9 00	 sbb	 ecx, 0
  00199	89 45 c4	 mov	 DWORD PTR __Pad$[ebp], eax
  0019c	89 4d c8	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
  0019f	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  001a3	0f 8c 85 00 00
	00		 jl	 $LN3@operator
  001a9	7f 06		 jg	 SHORT $LN26@operator
  001ab	83 7d c4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  001af	76 7d		 jbe	 SHORT $LN3@operator
$LN26@operator:

; 782  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  001b1	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b6	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001b9	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001bc	8b f4		 mov	 esi, esp
  001be	8b ca		 mov	 ecx, edx
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  001c6	3b f4		 cmp	 esi, esp
  001c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cd	8b f4		 mov	 esi, esp
  001cf	0f b6 c0	 movzx	 eax, al
  001d2	50		 push	 eax
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001d6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001db	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001de	8b fc		 mov	 edi, esp
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001e6	3b fc		 cmp	 edi, esp
  001e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ed	8b c8		 mov	 ecx, eax
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001f5	3b f4		 cmp	 esi, esp
  001f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fc	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv137[ebp], eax
  00202	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv137[ebp]
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00214	83 c4 08	 add	 esp, 8
  00217	0f b6 c8	 movzx	 ecx, al
  0021a	85 c9		 test	 ecx, ecx
  0021c	74 0b		 je	 SHORT $LN12@operator

; 783  :                     _State |= ios_base::badbit; // insertion failed, quit

  0021e	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00221	83 c8 04	 or	 eax, 4
  00224	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 784  :                     break;

  00227	eb 05		 jmp	 SHORT $LN3@operator
$LN12@operator:

; 785  :                 }
; 786  :             }

  00229	e9 5f ff ff ff	 jmp	 $LN2@operator
$LN3@operator:

; 787  :         }
; 788  : 
; 789  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0022e	83 7d e4 00	 cmp	 DWORD PTR __State$[ebp], 0
  00232	75 64		 jne	 SHORT $LN13@operator
  00234	8b f4		 mov	 esi, esp
  00236	8b 45 d8	 mov	 eax, DWORD PTR __Count$[ebp+4]
  00239	50		 push	 eax
  0023a	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0023d	51		 push	 ecx
  0023e	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00241	52		 push	 edx
  00242	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00245	8b 08		 mov	 ecx, DWORD PTR [eax]
  00247	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0024a	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0024d	8b fc		 mov	 edi, esp
  0024f	8b ca		 mov	 ecx, edx
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00257	3b fc		 cmp	 edi, esp
  00259	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025e	8b c8		 mov	 ecx, eax
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  00266	3b f4		 cmp	 esi, esp
  00268	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0026d	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv284[ebp], eax
  00273	89 95 e0 fe ff
	ff		 mov	 DWORD PTR tv284[ebp+4], edx
  00279	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv284[ebp]
  0027f	3b 45 d4	 cmp	 eax, DWORD PTR __Count$[ebp]
  00282	75 0b		 jne	 SHORT $LN27@operator
  00284	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv284[ebp+4]
  0028a	3b 4d d8	 cmp	 ecx, DWORD PTR __Count$[ebp+4]
  0028d	74 09		 je	 SHORT $LN13@operator
$LN27@operator:

; 790  :             _State |= ios_base::badbit;

  0028f	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00292	83 c8 04	 or	 eax, 4
  00295	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 791  :         }
; 792  : 
; 793  :         if (_State == ios_base::goodbit) {

  00298	83 7d e4 00	 cmp	 DWORD PTR __State$[ebp], 0
  0029c	0f 85 a3 00 00
	00		 jne	 $LN6@operator

; 794  :             for (; 0 < _Pad; --_Pad) { // pad on right

  002a2	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002a4	8b 45 c4	 mov	 eax, DWORD PTR __Pad$[ebp]
  002a7	83 e8 01	 sub	 eax, 1
  002aa	8b 4d c8	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  002ad	83 d9 00	 sbb	 ecx, 0
  002b0	89 45 c4	 mov	 DWORD PTR __Pad$[ebp], eax
  002b3	89 4d c8	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
  002b6	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  002ba	0f 8c 85 00 00
	00		 jl	 $LN6@operator
  002c0	7f 06		 jg	 SHORT $LN28@operator
  002c2	83 7d c4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002c6	76 7d		 jbe	 SHORT $LN6@operator
$LN28@operator:

; 795  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002c8	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cd	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002d0	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d3	8b f4		 mov	 esi, esp
  002d5	8b ca		 mov	 ecx, edx
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  002dd	3b f4		 cmp	 esi, esp
  002df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e4	8b f4		 mov	 esi, esp
  002e6	0f b6 c0	 movzx	 eax, al
  002e9	50		 push	 eax
  002ea	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ef	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f2	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002f5	8b fc		 mov	 edi, esp
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002fd	3b fc		 cmp	 edi, esp
  002ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00304	8b c8		 mov	 ecx, eax
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0030c	3b f4		 cmp	 esi, esp
  0030e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00313	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv285[ebp], eax
  00319	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  0031f	50		 push	 eax
  00320	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00325	50		 push	 eax
  00326	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0032b	83 c4 08	 add	 esp, 8
  0032e	0f b6 c8	 movzx	 ecx, al
  00331	85 c9		 test	 ecx, ecx
  00333	74 0b		 je	 SHORT $LN15@operator

; 796  :                     _State |= ios_base::badbit; // insertion failed, quit

  00335	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00338	83 c8 04	 or	 eax, 4
  0033b	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 797  :                     break;

  0033e	eb 05		 jmp	 SHORT $LN6@operator
$LN15@operator:

; 798  :                 }
; 799  :             }

  00340	e9 5f ff ff ff	 jmp	 $LN5@operator
$LN6@operator:

; 800  :         }
; 801  : 
; 802  :         _Ostr.width(0);

  00345	8b f4		 mov	 esi, esp
  00347	6a 00		 push	 0
  00349	6a 00		 push	 0
  0034b	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0034e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00350	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00353	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00356	8b ca		 mov	 ecx, edx
  00358	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  0035e	3b f4		 cmp	 esi, esp
  00360	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00365	eb 26		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 803  :         _CATCH_IO_(ios_base, _Ostr)

  00367	8b f4		 mov	 esi, esp
  00369	6a 01		 push	 1
  0036b	6a 04		 push	 4
  0036d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00375	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00378	8b ca		 mov	 ecx, edx
  0037a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00380	3b f4		 cmp	 esi, esp
  00382	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00387	b8 00 00 00 00	 mov	 eax, $LN23@operator
  0038c	c3		 ret	 0
$LN19@operator:
  0038d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00394	eb 07		 jmp	 SHORT $LN22@operator
$LN23@operator:
  00396	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN22@operator:

; 804  :     }
; 805  : 
; 806  :     _Ostr.setstate(_State);

  0039d	8b f4		 mov	 esi, esp
  0039f	6a 00		 push	 0
  003a1	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  003a4	50		 push	 eax
  003a5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003a8	8b 11		 mov	 edx, DWORD PTR [ecx]
  003aa	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003ad	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003b6	3b f4		 cmp	 esi, esp
  003b8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 807  :     return _Ostr;

  003bd	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003c0	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  003c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003cd	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  003d0	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  003d5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 808  : }

  003db	52		 push	 edx
  003dc	8b cd		 mov	 ecx, ebp
  003de	50		 push	 eax
  003df	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@operator
  003e5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003ea	58		 pop	 eax
  003eb	5a		 pop	 edx
  003ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003f6	59		 pop	 ecx
  003f7	5f		 pop	 edi
  003f8	5e		 pop	 esi
  003f9	5b		 pop	 ebx
  003fa	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fd	33 cd		 xor	 ecx, ebp
  003ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00404	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  0040a	3b ec		 cmp	 ebp, esp
  0040c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00411	8b e5		 mov	 esp, ebp
  00413	5d		 pop	 ebp
  00414	c3		 ret	 0
  00415	0f 1f 00	 npad	 3
$LN32@operator:
  00418	01 00 00 00	 DD	 1
  0041c	00 00 00 00	 DD	 $LN31@operator
$LN31@operator:
  00420	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00424	08 00 00 00	 DD	 8
  00428	00 00 00 00	 DD	 $LN29@operator
$LN29@operator:
  0042c	5f		 DB	 95			; 0000005fH
  0042d	4f		 DB	 79			; 0000004fH
  0042e	6b		 DB	 107			; 0000006bH
  0042f	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a c8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-312]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\лабы\2 семестр\кпо\лаб.1\dates\dates\birthday.cpp
;	COMDAT ?getParametersOfBirthday@@YAXHHHHH@Z
_TEXT	SEGMENT
_fourhungreed$ = -20					; size = 4
_four$ = -8						; size = 4
_year$ = 8						; size = 4
_month$ = 12						; size = 4
_month_of_birthday$ = 16				; size = 4
_day$ = 20						; size = 4
_day_of_birthday$ = 24					; size = 4
?getParametersOfBirthday@@YAXHHHHH@Z PROC		; getParametersOfBirthday, COMDAT

; 5    : static void getParametersOfBirthday(int year, int month, int month_of_birthday, int day, int day_of_birthday) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0000f	b9 06 00 00 00	 mov	 ecx, 6
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __DA04E707_birthday@cpp
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6    : 
; 7    : 	int four = 4, fourhungreed = 400;

  00025	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _four$[ebp], 4
  0002c	c7 45 ec 90 01
	00 00		 mov	 DWORD PTR _fourhungreed$[ebp], 400 ; 00000190H

; 8    : 	if (month > month_of_birthday || ((day > day_of_birthday) && (month == month_of_birthday))) {

  00033	8b 45 0c	 mov	 eax, DWORD PTR _month$[ebp]
  00036	3b 45 10	 cmp	 eax, DWORD PTR _month_of_birthday$[ebp]
  00039	7f 18		 jg	 SHORT $LN3@getParamet
  0003b	8b 45 14	 mov	 eax, DWORD PTR _day$[ebp]
  0003e	3b 45 18	 cmp	 eax, DWORD PTR _day_of_birthday$[ebp]
  00041	0f 8e b9 00 00
	00		 jle	 $LN8@getParamet
  00047	8b 45 0c	 mov	 eax, DWORD PTR _month$[ebp]
  0004a	3b 45 10	 cmp	 eax, DWORD PTR _month_of_birthday$[ebp]
  0004d	0f 85 ad 00 00
	00		 jne	 $LN8@getParamet
$LN3@getParamet:

; 9    : 		if (((year + 1) % four == 0) || ((year + 1) % fourhungreed == 0)) {

  00053	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	99		 cdq
  0005a	f7 7d f8	 idiv	 DWORD PTR _four$[ebp]
  0005d	85 d2		 test	 edx, edx
  0005f	74 0e		 je	 SHORT $LN6@getParamet
  00061	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	99		 cdq
  00068	f7 7d ec	 idiv	 DWORD PTR _fourhungreed$[ebp]
  0006b	85 d2		 test	 edx, edx
  0006d	75 2b		 jne	 SHORT $LN4@getParamet
$LN6@getParamet:

; 10   : 			cout << "год високосный:" << endl;

  0006f	8b f4		 mov	 esi, esp
  00071	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LCFMICKJ@?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?3@
  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00086	83 c4 08	 add	 esp, 8
  00089	8b c8		 mov	 ecx, eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 11   : 
; 12   : 		}

  00098	eb 66		 jmp	 SHORT $LN8@getParamet
$LN4@getParamet:

; 13   : 		else if ((year + 1) % 100 == 0) {

  0009a	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  0009d	83 c0 01	 add	 eax, 1
  000a0	99		 cdq
  000a1	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000a6	f7 f9		 idiv	 ecx
  000a8	85 d2		 test	 edx, edx
  000aa	75 2b		 jne	 SHORT $LN7@getParamet

; 14   : 			cout << "год невисокосный:" << endl;

  000ac	8b f4		 mov	 esi, esp
  000ae	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CIPPACFL@?c?n?d?5?m?e?b?h?q?n?j?n?q?m?$PL?i?3@
  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c3	83 c4 08	 add	 esp, 8
  000c6	8b c8		 mov	 ecx, eax
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 15   : 		}

  000d5	eb 29		 jmp	 SHORT $LN8@getParamet
$LN7@getParamet:

; 16   : 		else {
; 17   : 			cout << "год невисокосный:" << endl;

  000d7	8b f4		 mov	 esi, esp
  000d9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CIPPACFL@?c?n?d?5?m?e?b?h?q?n?j?n?q?m?$PL?i?3@
  000e3	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000ee	83 c4 08	 add	 esp, 8
  000f1	8b c8		 mov	 ecx, eax
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@getParamet:

; 18   : 		}
; 19   : 	}
; 20   : }

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00109	3b ec		 cmp	 ebp, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
?getParametersOfBirthday@@YAXHHHHH@Z ENDP		; getParametersOfBirthday
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\лабы\2 семестр\кпо\лаб.1\dates\dates\month_and_day.cpp
;	COMDAT ?findDayAndMonth@@YAHHHZZ
_TEXT	SEGMENT
_i$1 = -104						; size = 4
_result$ = -92						; size = 4
_thirty_one$ = -80					; size = 4
_thirty$ = -68						; size = 4
_zero$ = -56						; size = 4
_sum$ = -44						; size = 4
_eight$ = -32						; size = 4
_fourhungreed$ = -20					; size = 4
_four$ = -8						; size = 4
_day$ = 8						; size = 4
_month$ = 12						; size = 4
?findDayAndMonth@@YAHHHZZ PROC				; findDayAndMonth, COMDAT

; 5    : static int findDayAndMonth(int day, int month ...) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d 94	 lea	 edi, DWORD PTR [ebp-108]
  0000f	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __F25AC591_month_and_day@cpp
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6    : 
; 7    : 	int four = 4, fourhungreed = 400, eight = 8, sum = 0, zero = 0, thirty = 30, thirty_one = 31, result;

  00025	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _four$[ebp], 4
  0002c	c7 45 ec 90 01
	00 00		 mov	 DWORD PTR _fourhungreed$[ebp], 400 ; 00000190H
  00033	c7 45 e0 08 00
	00 00		 mov	 DWORD PTR _eight$[ebp], 8
  0003a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _sum$[ebp], 0
  00041	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _zero$[ebp], 0
  00048	c7 45 bc 1e 00
	00 00		 mov	 DWORD PTR _thirty$[ebp], 30 ; 0000001eH
  0004f	c7 45 b0 1f 00
	00 00		 mov	 DWORD PTR _thirty_one$[ebp], 31 ; 0000001fH

; 8    : 
; 9    : 	if (month >= 2) {

  00056	83 7d 0c 02	 cmp	 DWORD PTR _month$[ebp], 2
  0005a	7c 72		 jl	 SHORT $LN5@findDayAnd

; 10   : 		for (int i = 0; i < month - 1; i++) {

  0005c	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00063	eb 09		 jmp	 SHORT $LN4@findDayAnd
$LN2@findDayAnd:
  00065	8b 45 98	 mov	 eax, DWORD PTR _i$1[ebp]
  00068	83 c0 01	 add	 eax, 1
  0006b	89 45 98	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@findDayAnd:
  0006e	8b 45 0c	 mov	 eax, DWORD PTR _month$[ebp]
  00071	83 e8 01	 sub	 eax, 1
  00074	39 45 98	 cmp	 DWORD PTR _i$1[ebp], eax
  00077	7d 29		 jge	 SHORT $LN3@findDayAnd

; 11   : 			if (i % 2 == 0) {

  00079	8b 45 98	 mov	 eax, DWORD PTR _i$1[ebp]
  0007c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00081	79 05		 jns	 SHORT $LN13@findDayAnd
  00083	48		 dec	 eax
  00084	83 c8 fe	 or	 eax, -2			; fffffffeH
  00087	40		 inc	 eax
$LN13@findDayAnd:
  00088	85 c0		 test	 eax, eax
  0008a	75 0b		 jne	 SHORT $LN7@findDayAnd

; 12   : 				sum += thirty_one;

  0008c	8b 45 d4	 mov	 eax, DWORD PTR _sum$[ebp]
  0008f	03 45 b0	 add	 eax, DWORD PTR _thirty_one$[ebp]
  00092	89 45 d4	 mov	 DWORD PTR _sum$[ebp], eax

; 13   : 			}

  00095	eb 09		 jmp	 SHORT $LN8@findDayAnd
$LN7@findDayAnd:

; 14   : 			else {
; 15   : 				sum += thirty;

  00097	8b 45 d4	 mov	 eax, DWORD PTR _sum$[ebp]
  0009a	03 45 bc	 add	 eax, DWORD PTR _thirty$[ebp]
  0009d	89 45 d4	 mov	 DWORD PTR _sum$[ebp], eax
$LN8@findDayAnd:

; 16   : 			}
; 17   : 		}

  000a0	eb c3		 jmp	 SHORT $LN2@findDayAnd
$LN3@findDayAnd:

; 18   : 
; 19   : 		if (month == 2 || month == 9 || month == 11) {

  000a2	83 7d 0c 02	 cmp	 DWORD PTR _month$[ebp], 2
  000a6	74 0c		 je	 SHORT $LN11@findDayAnd
  000a8	83 7d 0c 09	 cmp	 DWORD PTR _month$[ebp], 9
  000ac	74 06		 je	 SHORT $LN11@findDayAnd
  000ae	83 7d 0c 0b	 cmp	 DWORD PTR _month$[ebp], 11 ; 0000000bH
  000b2	75 0b		 jne	 SHORT $LN9@findDayAnd
$LN11@findDayAnd:

; 20   : 			result = sum + day;

  000b4	8b 45 d4	 mov	 eax, DWORD PTR _sum$[ebp]
  000b7	03 45 08	 add	 eax, DWORD PTR _day$[ebp]
  000ba	89 45 a4	 mov	 DWORD PTR _result$[ebp], eax

; 21   : 		}

  000bd	eb 0d		 jmp	 SHORT $LN10@findDayAnd
$LN9@findDayAnd:

; 22   : 
; 23   : 		else {
; 24   : 			result = sum - 1 + day;

  000bf	8b 45 08	 mov	 eax, DWORD PTR _day$[ebp]
  000c2	8b 4d d4	 mov	 ecx, DWORD PTR _sum$[ebp]
  000c5	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  000c9	89 55 a4	 mov	 DWORD PTR _result$[ebp], edx
$LN10@findDayAnd:

; 25   : 		}
; 26   : 	}

  000cc	eb 06		 jmp	 SHORT $LN6@findDayAnd
$LN5@findDayAnd:

; 27   : 	else {
; 28   : 		result = day;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _day$[ebp]
  000d1	89 45 a4	 mov	 DWORD PTR _result$[ebp], eax
$LN6@findDayAnd:

; 29   : 	}
; 30   : 	return result;

  000d4	8b 45 a4	 mov	 eax, DWORD PTR _result$[ebp]

; 31   : }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  000e0	3b ec		 cmp	 ebp, esp
  000e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
?findDayAndMonth@@YAHHHZZ ENDP				; findDayAndMonth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 68   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 69   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00025	c6 45 fb 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 70   : 
; 71   :     if constexpr (_Overflow_is_possible) {
; 72   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 73   :         if (_Count > _Max_possible) {
; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 79   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Ptr_container$ = -20					; size = 4
__Block_size$ = -8					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 140  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 141  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00025	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00028	83 c0 27	 add	 eax, 39			; 00000027H
  0002b	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 143  :     if (_Block_size <= _Bytes) {

  0002e	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00031	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00034	77 05		 ja	 SHORT $LN8@Allocate_m

; 144  :         _Throw_bad_array_new_length(); // add overflow

  00036	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 145  :     }
; 146  : 
; 147  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0003b	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004a	83 7d ec 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0004e	74 02		 je	 SHORT $LN9@Allocate_m
  00050	eb 5c		 jmp	 SHORT $LN6@Allocate_m
$LN9@Allocate_m:
  00052	8b f4		 mov	 esi, esp
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0005e	6a 00		 push	 0
  00060	68 94 00 00 00	 push	 148			; 00000094H
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@IGIKFMFC@C?3?2Program?5Files?2Microsoft?5Visu@
  0006a	6a 02		 push	 2
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00072	83 c4 18	 add	 esp, 24			; 00000018H
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	75 01		 jne	 SHORT $LN12@Allocate_m
  00081	cc		 int	 3
$LN12@Allocate_m:
  00082	8b f4		 mov	 esi, esp
  00084	6a 00		 push	 0
  00086	68 94 00 00 00	 push	 148			; 00000094H
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@LJPJJNIE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000a0	83 c4 14	 add	 esp, 20			; 00000014H
  000a3	3b f4		 cmp	 esi, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	33 c0		 xor	 eax, eax
  000ac	75 a4		 jne	 SHORT $LN9@Allocate_m
$LN6@Allocate_m:
  000ae	33 c0		 xor	 eax, eax
  000b0	75 98		 jne	 SHORT $LN4@Allocate_m

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000b2	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000b5	83 c0 27	 add	 eax, 39			; 00000027H
  000b8	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000bb	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000be	b8 04 00 00 00	 mov	 eax, 4
  000c3	6b c8 ff	 imul	 ecx, eax, -1
  000c6	8b 55 e0	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000c9	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000cc	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 151  : 
; 152  : #ifdef _DEBUG
; 153  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000cf	b8 04 00 00 00	 mov	 eax, 4
  000d4	6b c8 fe	 imul	 ecx, eax, -2
  000d7	8b 55 e0	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000da	c7 04 0a fa fa
	fa fa		 mov	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH

; 154  : #endif // defined(_DEBUG)
; 155  :     return _Ptr;

  000e1	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN1@Allocate_m:

; 156  : }

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000ed	3b ec		 cmp	 ebp, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2202 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2203 : #if _HAS_CXX23
; 2204 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2205 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2206 :         _Count                  = _Allocated;
; 2207 :         return _Ptr;
; 2208 :     } else
; 2209 : #endif // _HAS_CXX23
; 2210 :     {
; 2211 :         return _Al.allocate(_Count);

  00021	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0002a	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 2212 :     }
; 2213 : }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 709  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 710  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 711  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 712  :         if (_STD is_constant_evaluated()) {
; 713  :             _Al.deallocate(_Ptr, _Count);
; 714  :         } else
; 715  : #endif // _HAS_CXX20
; 716  :         {
; 717  :             (void) _Al;
; 718  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00021	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00024	c1 e0 03	 shl	 eax, 3
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00031	83 c4 08	 add	 esp, 8

; 719  :         }
; 720  :     }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 1528 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __7C4A1519_type_traits
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1584 :     return __builtin_addressof(_Val);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 234  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 235  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 236  : #if defined(_M_IX86) || defined(_M_X64)
; 237  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 238  :     if (!_STD is_constant_evaluated())
; 239  : #endif // _HAS_CXX20
; 240  :     {
; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00021	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00028	72 0e		 jb	 SHORT $LN2@Allocate

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00033	83 c4 04	 add	 esp, 4
  00036	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  00038	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0003c	74 0e		 je	 SHORT $LN3@Allocate

; 248  :         return _Traits::_Allocate(_Bytes);

  0003e	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00047	83 c4 04	 add	 esp, 4
  0004a	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  0004c	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 252  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 68   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0000f	b9 06 00 00 00	 mov	 ecx, 6
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 69   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00025	c6 45 fb 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 70   : 
; 71   :     if constexpr (_Overflow_is_possible) {
; 72   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00029	c7 45 ec ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 73   :         if (_Count > _Max_possible) {

  00030	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00037	76 05		 jbe	 SHORT $LN2@Get_size_o

; 74   :             _Throw_bad_array_new_length(); // multiply overflow

  00039	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  0003e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00041	c1 e0 03	 shl	 eax, 3
$LN1@Get_size_o:

; 79   : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __7C4A1519_type_traits
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1584 :     return __builtin_addressof(_Val);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __C27AFEEB_xutility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00025	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	6a 04		 push	 4
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00042	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00048	8b 55 0c	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  0004b	8b 02		 mov	 eax, DWORD PTR [edx]
  0004d	89 01		 mov	 DWORD PTR [ecx], eax

; 256  :     }
; 257  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z
_TEXT	SEGMENT
__Fancy_ptr$ = -8					; size = 4
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 2611 :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2612 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2613 :         ++_Capacity; // Take null terminator into consideration

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	83 c1 01	 add	 ecx, 1
  0002d	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00030	89 0a		 mov	 DWORD PTR [edx], ecx

; 2614 : 
; 2615 :         pointer _Fancy_ptr;
; 2616 :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 2617 :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

  00032	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  0003f	83 c4 08	 add	 esp, 8
  00042	89 45 f8	 mov	 DWORD PTR __Fancy_ptr$[ebp], eax

; 2618 :         } else {
; 2619 :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 2620 :             _Fancy_ptr = _Al.allocate(_Capacity);
; 2621 :         }
; 2622 : 
; 2623 : #if _HAS_CXX20
; 2624 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2625 :         // but likely more impactful to throughput.
; 2626 :         if (_STD is_constant_evaluated()) {
; 2627 :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 2628 :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 2629 :                 _STD construct_at(_Ptr + _Idx);
; 2630 :             }
; 2631 :         }
; 2632 : #endif // _HAS_CXX20
; 2633 :         --_Capacity;

  00045	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	83 e9 01	 sub	 ecx, 1
  0004d	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00050	89 0a		 mov	 DWORD PTR [edx], ecx

; 2634 :         return _Fancy_ptr;

  00052	8b 45 f8	 mov	 eax, DWORD PTR __Fancy_ptr$[ebp]

; 2635 :     }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 36   :     return _Ptr;

  00021	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1487 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1488 :         if (_Ptr) {

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00030	74 15		 je	 SHORT $LN2@Container_

; 1489 :             _Delete_plain_internal(_Al, _Ptr);

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	51		 push	 ecx
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00044	83 c4 08	 add	 esp, 8
$LN2@Container_:

; 1490 :         }
; 1491 :     }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1473 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00038	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1474 :         // create a new _Container_proxy pointing at _Mycont
; 1475 :         _Ptr = _Unfancy(_Al_.allocate(1));

  0003b	6a 01		 push	 1
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00040	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  0004b	83 c4 04	 add	 esp, 4
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	89 01		 mov	 DWORD PTR [ecx], eax

; 1476 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  00053	8b 45 0c	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00065	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0006b	51		 push	 ecx
  0006c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 02		 mov	 eax, DWORD PTR [edx]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00077	83 c4 08	 add	 esp, 8

; 1477 :         _Mycont._Myproxy = _Ptr;

  0007a	8b 45 0c	 mov	 eax, DWORD PTR __Mycont$[ebp]
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 11		 mov	 edx, DWORD PTR [ecx]
  00082	89 10		 mov	 DWORD PTR [eax], edx

; 1478 :     }

  00084	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1127 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1128 :     // deallocate a plain pointer using an allocator
; 1129 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1130 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1131 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00041	6a 01		 push	 1
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1132 :     } else {
; 1133 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1134 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1135 :     }
; 1136 : }

  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
  00072	cc		 int	 3
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
  00076	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 255  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 256  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 257  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 258  :     if (_STD is_constant_evaluated()) {
; 259  :         ::operator delete(_Ptr);
; 260  :     } else
; 261  : #endif // _HAS_CXX20
; 262  :     {
; 263  : #if defined(_M_IX86) || defined(_M_X64)
; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00041	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00048	72 10		 jb	 SHORT $LN2@Deallocate

; 265  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004a	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0004d	50		 push	 eax
  0004e	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00057	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 266  :         }
; 267  : #endif // defined(_M_IX86) || defined(_M_X64)
; 268  :         ::operator delete(_Ptr, _Bytes);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00067	83 c4 08	 add	 esp, 8

; 269  :     }
; 270  : }

  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
  00089	cc		 int	 3
  0008a	cc		 int	 3
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 75   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  0000f	b9 04 00 00 00	 mov	 ecx, 4
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2F328FEB_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

  00025	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002b	8b 10		 mov	 edx, DWORD PTR [eax]
  0002d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0002f	73 0b		 jae	 SHORT $LN3@max
  00031	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00034	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0003a	eb 09		 jmp	 SHORT $LN4@max
$LN3@max:
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0003f	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  00045	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp]
  0004b	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  00051	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]

; 78   : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 307  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 308  :     if constexpr (is_array_v<_Ty>) {
; 309  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 310  :     } else {
; 311  :         _Obj.~_Ty();
; 312  :     }
; 313  : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 36   :     return _Ptr;

  00021	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z
_TEXT	SEGMENT
__Old_ptr$1 = -120					; size = 4
__Raw_new$ = -108					; size = 4
__New_ptr$ = -96					; size = 4
__Al$ = -84						; size = 4
__New_capacity$ = -72					; size = 4
__Old_capacity$ = -60					; size = 4
__New_size$ = -48					; size = 4
__Old_size$ = -36					; size = 4
__My_data$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  00010	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00034	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0003a	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00040	89 4d dc	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00043	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0004b	2b 45 dc	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0004e	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00051	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00053	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  00058	8b 45 dc	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0005b	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  0005e	89 45 d0	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00061	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00064	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00067	89 4d c4	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0006a	8b 45 d0	 mov	 eax, DWORD PTR __New_size$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00076	89 45 b8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  00079	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00081	89 45 ac	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00084	8d 45 b8	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  00087	50		 push	 eax
  00088	8b 4d ac	 mov	 ecx, DWORD PTR __Al$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00091	83 c4 08	 add	 esp, 8
  00094	89 45 a0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  00097	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0009a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  0009f	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a2	8b 4d d0	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000a5	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  000a8	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ab	8b 4d b8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000ae	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b1	8b 45 a0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 94	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  000c0	83 7d c4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  000c4	76 4a		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c6	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	89 4d 88	 mov	 DWORD PTR __Old_ptr$1[ebp], ecx

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000cf	0f b6 45 10	 movzx	 eax, BYTE PTR _<_Args_0>$[ebp]
  000d3	50		 push	 eax
  000d4	8b 4d dc	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000d7	51		 push	 ecx
  000d8	8b 55 88	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000e1	83 c4 04	 add	 esp, 4
  000e4	50		 push	 eax
  000e5	8b 45 94	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000e8	50		 push	 eax
  000e9	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000ec	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000f1	8b 45 c4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d 88	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000f8	51		 push	 ecx
  000f9	8b 55 ac	 mov	 edx, DWORD PTR __Al$[ebp]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00108	8b 4d a0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0010b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4832 :         } else {

  0010e	eb 2f		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  00110	0f b6 45 10	 movzx	 eax, BYTE PTR _<_Args_0>$[ebp]
  00114	50		 push	 eax
  00115	8b 4d dc	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00118	51		 push	 ecx
  00119	8b 55 e8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0011c	83 c2 04	 add	 edx, 4
  0011f	52		 push	 edx
  00120	8b 45 94	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00123	50		 push	 eax
  00124	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  00127	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0012c	8d 45 a0	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  0012f	50		 push	 eax
  00130	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00133	83 c1 04	 add	 ecx, 4
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0013c	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  0013f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  00142	52		 push	 edx
  00143	8b cd		 mov	 ecx, ebp
  00145	50		 push	 eax
  00146	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@Reallocate
  0014c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00151	58		 pop	 eax
  00152	5a		 pop	 edx
  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx
  00156	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	33 cd		 xor	 ecx, ebp
  0015b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00160	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  00166	3b ec		 cmp	 ebp, esp
  00168	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 0c 00	 ret	 12			; 0000000cH
  00173	90		 npad	 1
$LN9@Reallocate:
  00174	02 00 00 00	 DD	 2
  00178	00 00 00 00	 DD	 $LN8@Reallocate
$LN8@Reallocate:
  0017c	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00180	04 00 00 00	 DD	 4
  00184	00 00 00 00	 DD	 $LN6@Reallocate
  00188	a0 ff ff ff	 DD	 -96			; ffffffa0H
  0018c	04 00 00 00	 DD	 4
  00190	00 00 00 00	 DD	 $LN7@Reallocate
$LN7@Reallocate:
  00194	5f		 DB	 95			; 0000005fH
  00195	4e		 DB	 78			; 0000004eH
  00196	65		 DB	 101			; 00000065H
  00197	77		 DB	 119			; 00000077H
  00198	5f		 DB	 95			; 0000005fH
  00199	70		 DB	 112			; 00000070H
  0019a	74		 DB	 116			; 00000074H
  0019b	72		 DB	 114			; 00000072H
  0019c	00		 DB	 0
$LN6@Reallocate:
  0019d	5f		 DB	 95			; 0000005fH
  0019e	4e		 DB	 78			; 0000004eH
  0019f	65		 DB	 101			; 00000065H
  001a0	77		 DB	 119			; 00000077H
  001a1	5f		 DB	 95			; 0000005fH
  001a2	63		 DB	 99			; 00000063H
  001a3	61		 DB	 97			; 00000061H
  001a4	70		 DB	 112			; 00000070H
  001a5	61		 DB	 97			; 00000061H
  001a6	63		 DB	 99			; 00000063H
  001a7	69		 DB	 105			; 00000069H
  001a8	74		 DB	 116			; 00000074H
  001a9	79		 DB	 121			; 00000079H
  001aa	00		 DB	 0
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT
; _this$ = ecx

; 4095 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4096 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  0002a	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4097 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0003e	8d 45 14	 lea	 eax, DWORD PTR __Ch$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00045	03 4d 10	 add	 ecx, DWORD PTR __Old_size$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0004e	83 c4 08	 add	 esp, 8

; 4098 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00051	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00058	8d 85 2f ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00062	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00065	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0006f	83 c4 08	 add	 esp, 8

; 4099 :             },

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 10 00	 ret	 16			; 00000010H
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
$T2 = -325						; size = 1
$T3 = -313						; size = 1
__New_ptr$ = -112					; size = 4
__New_capacity$ = -100					; size = 4
__Proxy$ = -88						; size = 8
_$S10$ = -69						; size = 1
__Alproxy$ = -60					; size = 4
__Al$ = -48						; size = 4
__My_data$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 2659 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00021	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2660 :         auto& _My_data = _Mypair._Myval2;

  0004f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00052	89 45 dc	 mov	 DWORD PTR __My_data$[ebp], eax

; 2661 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2662 : 
; 2663 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2664 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2665 :         } else {
; 2666 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2667 :         }
; 2668 : 
; 2669 :         if (_Count > max_size()) {

  00055	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0005d	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  00060	76 05		 jbe	 SHORT $LN2@Construct

; 2670 :             _Xlen_string(); // result too long

  00062	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();

  00067	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0006f	89 45 d0	 mov	 DWORD PTR __Al$[ebp], eax

; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  00072	8b 45 d0	 mov	 eax, DWORD PTR __Al$[ebp]
  00075	50		 push	 eax
  00076	8d 4d bb	 lea	 ecx, DWORD PTR _$S10$[ebp]
  00079	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0007e	8d 4d bb	 lea	 ecx, DWORD PTR _$S10$[ebp]
  00081	89 4d c4	 mov	 DWORD PTR __Alproxy$[ebp], ecx

; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00084	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00087	50		 push	 eax
  00088	8b 4d c4	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  0008b	51		 push	 ecx
  0008c	8d 4d a8	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0008f	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00094	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  0009b	83 7d 0c 0f	 cmp	 DWORD PTR __Count$[ebp], 15 ; 0000000fH
  0009f	77 67		 ja	 SHORT $LN3@Construct

; 2678 :             _My_data._Mysize = _Count;

  000a1	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a4	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  000a7	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  000aa	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ad	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 2680 : 
; 2681 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2682 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2683 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2684 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2685 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

  000b4	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR __Arg$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 dc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000bf	83 c2 04	 add	 edx, 4
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  000cb	c6 85 c7 fe ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  000d2	8d 85 c7 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000d8	50		 push	 eax
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  000dc	8b 55 dc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000df	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000e9	83 c4 08	 add	 esp, 8

; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();

  000ec	8d 4d a8	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000ef	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2696 :             return;

  000f4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000fb	8d 4d a8	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000fe	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00103	e9 ac 00 00 00	 jmp	 $LN1@Construct
$LN3@Construct:

; 2697 :         }
; 2698 : 
; 2699 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  00108	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00110	50		 push	 eax
  00111	6a 0f		 push	 15			; 0000000fH
  00113	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	89 45 9c	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2700 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00122	8d 45 9c	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  00125	50		 push	 eax
  00126	8b 4d d0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  0012f	83 c4 08	 add	 esp, 8
  00132	89 45 90	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00135	8d 45 90	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00138	50		 push	 eax
  00139	8b 4d dc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0013c	83 c1 04	 add	 ecx, 4
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00145	83 c4 08	 add	 esp, 8

; 2702 : 
; 2703 :         _My_data._Mysize = _Count;

  00148	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0014b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0014e	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2704 :         _My_data._Myres  = _New_capacity;

  00151	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00154	8b 4d 9c	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00157	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 2705 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2706 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2707 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2708 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2709 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

  0015a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0015d	50		 push	 eax
  0015e	8b 4d 08	 mov	 ecx, DWORD PTR __Arg$[ebp]
  00161	51		 push	 ecx
  00162	8b 55 90	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0016b	83 c4 04	 add	 esp, 4
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00177	c6 85 bb fe ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
  0017e	8d 85 bb fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00184	50		 push	 eax
  00185	8b 4d 90	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00188	51		 push	 ecx
  00189	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0018e	83 c4 04	 add	 esp, 4
  00191	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0019a	83 c4 08	 add	 esp, 8

; 2711 :         } else { // _Strat == _Construct_strategy::_From_string
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2713 :         }
; 2714 : 
; 2715 :         _ASAN_STRING_CREATE(*this);
; 2716 :         _Proxy._Release();

  0019d	8d 4d a8	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  001a0	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2717 :     }

  001a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001ac	8d 4d a8	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  001af	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
$LN1@Construct:
  001b4	52		 push	 edx
  001b5	8b cd		 mov	 ecx, ebp
  001b7	50		 push	 eax
  001b8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Construct
  001be	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001c3	58		 pop	 eax
  001c4	5a		 pop	 edx
  001c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cf	59		 pop	 ecx
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d6	33 cd		 xor	 ecx, ebp
  001d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dd	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  001e3	3b ec		 cmp	 ebp, esp
  001e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c2 08 00	 ret	 8
$LN12@Construct:
  001f0	04 00 00 00	 DD	 4
  001f4	00 00 00 00	 DD	 $LN11@Construct
$LN11@Construct:
  001f8	bb ff ff ff	 DD	 -69			; ffffffbbH
  001fc	01 00 00 00	 DD	 1
  00200	00 00 00 00	 DD	 $LN6@Construct
  00204	a8 ff ff ff	 DD	 -88			; ffffffa8H
  00208	08 00 00 00	 DD	 8
  0020c	00 00 00 00	 DD	 $LN7@Construct
  00210	9c ff ff ff	 DD	 -100			; ffffff9cH
  00214	04 00 00 00	 DD	 4
  00218	00 00 00 00	 DD	 $LN8@Construct
  0021c	90 ff ff ff	 DD	 -112			; ffffff90H
  00220	04 00 00 00	 DD	 4
  00224	00 00 00 00	 DD	 $LN9@Construct
$LN9@Construct:
  00228	5f		 DB	 95			; 0000005fH
  00229	4e		 DB	 78			; 0000004eH
  0022a	65		 DB	 101			; 00000065H
  0022b	77		 DB	 119			; 00000077H
  0022c	5f		 DB	 95			; 0000005fH
  0022d	70		 DB	 112			; 00000070H
  0022e	74		 DB	 116			; 00000074H
  0022f	72		 DB	 114			; 00000072H
  00230	00		 DB	 0
$LN8@Construct:
  00231	5f		 DB	 95			; 0000005fH
  00232	4e		 DB	 78			; 0000004eH
  00233	65		 DB	 101			; 00000065H
  00234	77		 DB	 119			; 00000077H
  00235	5f		 DB	 95			; 0000005fH
  00236	63		 DB	 99			; 00000063H
  00237	61		 DB	 97			; 00000061H
  00238	70		 DB	 112			; 00000070H
  00239	61		 DB	 97			; 00000061H
  0023a	63		 DB	 99			; 00000063H
  0023b	69		 DB	 105			; 00000069H
  0023c	74		 DB	 116			; 00000074H
  0023d	79		 DB	 121			; 00000079H
  0023e	00		 DB	 0
$LN7@Construct:
  0023f	5f		 DB	 95			; 0000005fH
  00240	50		 DB	 80			; 00000050H
  00241	72		 DB	 114			; 00000072H
  00242	6f		 DB	 111			; 0000006fH
  00243	78		 DB	 120			; 00000078H
  00244	79		 DB	 121			; 00000079H
  00245	00		 DB	 0
$LN6@Construct:
  00246	24		 DB	 36			; 00000024H
  00247	53		 DB	 83			; 00000053H
  00248	31		 DB	 49			; 00000031H
  00249	30		 DB	 48			; 00000030H
  0024a	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a b0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-336]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1523 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 970  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
__New_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1211 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  00010	b9 09 00 00 00	 mov	 ecx, 9
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1212 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  0002a	6a 01		 push	 1
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0002f	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 45 ec	 mov	 DWORD PTR __New_proxy$[ebp], eax

; 1213 :         _Construct_in_place(*_New_proxy, this);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00049	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00059	83 c4 08	 add	 esp, 8

; 1214 :         _Myproxy            = _New_proxy;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR __New_proxy$[ebp]
  00062	89 08		 mov	 DWORD PTR [eax], ecx

; 1215 :         _New_proxy->_Mycont = this;

  00064	8b 45 ec	 mov	 eax, DWORD PTR __New_proxy$[ebp]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx

; 1216 :     }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1139 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1140 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1141 :     using _Ty = typename _Alloc::value_type;
; 1142 :     _Ptr->~_Ty();
; 1143 :     _Deallocate_plain(_Al, _Ptr);

  00021	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0002e	83 c4 08	 add	 esp, 8

; 1144 : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 980  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 981  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 982  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0003c	83 c4 04	 add	 esp, 4

; 983  :     }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 98   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  0000f	b9 04 00 00 00	 mov	 ecx, 4
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2F328FEB_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 99   :     // return smaller of _Left and _Right
; 100  :     return _Right < _Left ? _Right : _Left;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002b	8b 10		 mov	 edx, DWORD PTR [eax]
  0002d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0002f	73 0b		 jae	 SHORT $LN3@min
  00031	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00034	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0003a	eb 09		 jmp	 SHORT $LN4@min
$LN3@min:
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0003f	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00045	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp]
  0004b	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  00051	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]

; 101  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\string
;	COMDAT ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z
_TEXT	SEGMENT
__Ans$ = -48						; size = 4
__Eptr$ = -36						; size = 4
__Ptr$ = -24						; size = 4
__Errno_ref$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
__Str$ = 8						; size = 4
__Idx$ = 12						; size = 4
__Base$ = 16						; size = 4
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z PROC ; std::stoi, COMDAT

; 88   : _EXPORT_STD _NODISCARD inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  0000f	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __C1864A34_string
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 89   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  0002f	8b f4		 mov	 esi, esp
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	89 45 f4	 mov	 DWORD PTR __Errno_ref$[ebp], eax

; 90   :     const char* _Ptr = _Str.c_str();

  00041	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00044	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00049	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 91   :     char* _Eptr;
; 92   :     _Errno_ref      = 0;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Errno_ref$[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 93   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

  00055	8b f4		 mov	 esi, esp
  00057	8b 45 10	 mov	 eax, DWORD PTR __Base$[ebp]
  0005a	50		 push	 eax
  0005b	8d 4d dc	 lea	 ecx, DWORD PTR __Eptr$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00062	52		 push	 edx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	89 45 d0	 mov	 DWORD PTR __Ans$[ebp], eax

; 94   : 
; 95   :     if (_Ptr == _Eptr) {

  00076	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00079	3b 45 dc	 cmp	 eax, DWORD PTR __Eptr$[ebp]
  0007c	75 0a		 jne	 SHORT $LN2@stoi

; 96   :         _Xinvalid_argument("invalid stoi argument");

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
  00083	e8 00 00 00 00	 call	 ?_Xinvalid_argument@std@@YAXPBD@Z ; std::_Xinvalid_argument
$LN2@stoi:

; 97   :     }
; 98   : 
; 99   :     if (_Errno_ref == ERANGE) {

  00088	8b 45 f4	 mov	 eax, DWORD PTR __Errno_ref$[ebp]
  0008b	83 38 22	 cmp	 DWORD PTR [eax], 34	; 00000022H
  0008e	75 0a		 jne	 SHORT $LN3@stoi

; 100  :         _Xout_of_range("stoi argument out of range");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
  00095	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@stoi:

; 101  :     }
; 102  : 
; 103  :     if (_Idx) {

  0009a	83 7d 0c 00	 cmp	 DWORD PTR __Idx$[ebp], 0
  0009e	74 0b		 je	 SHORT $LN4@stoi

; 104  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);

  000a0	8b 45 dc	 mov	 eax, DWORD PTR __Eptr$[ebp]
  000a3	2b 45 e8	 sub	 eax, DWORD PTR __Ptr$[ebp]
  000a6	8b 4d 0c	 mov	 ecx, DWORD PTR __Idx$[ebp]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@stoi:

; 105  :     }
; 106  : 
; 107  :     return static_cast<int>(_Ans);

  000ab	8b 45 d0	 mov	 eax, DWORD PTR __Ans$[ebp]
$LN1@stoi:

; 108  : }

  000ae	52		 push	 edx
  000af	8b cd		 mov	 ecx, ebp
  000b1	50		 push	 eax
  000b2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@stoi
  000b8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000bd	58		 pop	 eax
  000be	5a		 pop	 edx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	33 cd		 xor	 ecx, ebp
  000c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cc	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
  000dd	0f 1f 00	 npad	 3
$LN8@stoi:
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN7@stoi
$LN7@stoi:
  000e8	dc ff ff ff	 DD	 -36			; ffffffdcH
  000ec	04 00 00 00	 DD	 4
  000f0	00 00 00 00	 DD	 $LN6@stoi
$LN6@stoi:
  000f4	5f		 DB	 95			; 0000005fH
  000f5	45		 DB	 69			; 00000045H
  000f6	70		 DB	 112			; 00000070H
  000f7	74		 DB	 116			; 00000074H
  000f8	72		 DB	 114			; 00000072H
  000f9	00		 DB	 0
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ENDP ; std::stoi
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1534 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1535 :         return *this;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1536 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1530 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1531 :         return *this;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1532 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4893 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4894 :         return _Mypair._Get_first();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4895 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4889 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4890 :         return _Mypair._Get_first();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4891 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -233						; size = 1
__Al$2 = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4863 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  00010	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4864 :         auto& _My_data = _Mypair._Myval2;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 4865 :         _My_data._Orphan_all();

  00030	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00038	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	74 30		 je	 SHORT $LN2@Tidy_deall

; 4867 :             _ASAN_STRING_REMOVE(*this);
; 4868 :             auto& _Al = _Getal();

  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0004f	89 45 e0	 mov	 DWORD PTR __Al$2[ebp], eax

; 4869 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

  00052	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00055	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00058	51		 push	 ecx
  00059	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  0005c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005f	50		 push	 eax
  00060	8b 4d e0	 mov	 ecx, DWORD PTR __Al$2[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4870 :             _My_data._Bx._Switch_to_buf();

  0006c	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	83 c1 04	 add	 ecx, 4
  00072	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
$LN2@Tidy_deall:

; 4871 :         }
; 4872 : 
; 4873 :         _My_data._Mysize = 0;

  00077	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00081	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00084	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0008b	c6 85 17 ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00092	8d 85 17 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00098	50		 push	 eax
  00099	b9 01 00 00 00	 mov	 ecx, 1
  0009e	6b d1 00	 imul	 edx, ecx, 0
  000a1	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a4	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000ae	83 c4 08	 add	 esp, 8

; 4877 :     }

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_size$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 4857 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4858 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 4859 :         _Mypair._Myval2._Mysize = _New_size;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00030	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4860 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

  00033	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  0003a	8d 85 2f ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00040	50		 push	 eax
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00049	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00052	83 c4 08	 add	 esp, 8

; 4861 :     }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4773 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4774 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00032	50		 push	 eax
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4775 :     }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -216						; size = 4
__Masked$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4760 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  0002f	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00032	83 c8 0f	 or	 eax, 15			; 0000000fH
  00035	89 45 f4	 mov	 DWORD PTR __Masked$[ebp], eax

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003b	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  0003e	76 05		 jbe	 SHORT $LN2@Calculate_

; 4763 :             return _Max;

  00040	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00043	eb 37		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4764 :         }
; 4765 : 
; 4766 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00045	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00048	d1 e8		 shr	 eax, 1
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  0004d	2b c8		 sub	 ecx, eax
  0004f	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00052	76 05		 jbe	 SHORT $LN3@Calculate_

; 4767 :             return _Max;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00057	eb 23		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4768 :         }
; 4769 : 
; 4770 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00059	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0005c	d1 e8		 shr	 eax, 1
  0005e	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00061	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00067	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0006d	51		 push	 ecx
  0006e	8d 55 f4	 lea	 edx, DWORD PTR __Masked$[ebp]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00077	83 c4 08	 add	 esp, 8
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Calculate_:

; 4771 :     }

  0007c	52		 push	 edx
  0007d	8b cd		 mov	 ecx, ebp
  0007f	50		 push	 eax
  00080	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Calculate_
  00086	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008b	58		 pop	 eax
  0008c	5a		 pop	 edx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
  000ab	90		 npad	 1
$LN8@Calculate_:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN7@Calculate_
$LN7@Calculate_:
  000b4	f4 ff ff ff	 DD	 -12			; fffffff4H
  000b8	04 00 00 00	 DD	 4
  000bc	00 00 00 00	 DD	 $LN6@Calculate_
$LN6@Calculate_:
  000c0	5f		 DB	 95			; 0000005fH
  000c1	4d		 DB	 77			; 0000004dH
  000c2	61		 DB	 97			; 00000061H
  000c3	73		 DB	 115			; 00000073H
  000c4	6b		 DB	 107			; 0000006bH
  000c5	65		 DB	 101			; 00000065H
  000c6	64		 DB	 100			; 00000064H
  000c7	00		 DB	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -264						; size = 4
$T2 = -252						; size = 4
$T3 = -240						; size = 4
__Storage_max$ = -36					; size = 4
__Alloc_max$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 4165 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  00010	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4166 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 e8	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 4167 :         const size_type _Storage_max = // can always store small string

  00048	c7 85 10 ff ff
	ff 10 00 00 00	 mov	 DWORD PTR $T3[ebp], 16	; 00000010H
  00052	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00058	50		 push	 eax
  00059	8d 4d e8	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00062	83 c4 08	 add	 esp, 8
  00065	8b 10		 mov	 edx, DWORD PTR [eax]
  00067	89 55 dc	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 4168 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4169 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0006a	8b 45 dc	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0006d	83 e8 01	 sub	 eax, 1
  00070	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00076	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  0007b	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00081	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00087	51		 push	 ecx
  00088	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00094	83 c4 08	 add	 esp, 8
  00097	8b 00		 mov	 eax, DWORD PTR [eax]

; 4170 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4171 :         );
; 4172 :     }

  00099	52		 push	 edx
  0009a	8b cd		 mov	 ecx, ebp
  0009c	50		 push	 eax
  0009d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@max_size
  000a3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a8	58		 pop	 eax
  000a9	5a		 pop	 edx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN6@max_size:
  000c8	01 00 00 00	 DD	 1
  000cc	00 00 00 00	 DD	 $LN5@max_size
$LN5@max_size:
  000d0	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000d4	04 00 00 00	 DD	 4
  000d8	00 00 00 00	 DD	 $LN4@max_size
$LN4@max_size:
  000dc	5f		 DB	 95			; 0000005fH
  000dd	41		 DB	 65			; 00000041H
  000de	6c		 DB	 108			; 0000006cH
  000df	6c		 DB	 108			; 0000006cH
  000e0	6f		 DB	 111			; 0000006fH
  000e1	63		 DB	 99			; 00000063H
  000e2	5f		 DB	 95			; 0000005fH
  000e3	6d		 DB	 109			; 0000006dH
  000e4	61		 DB	 97			; 00000061H
  000e5	78		 DB	 120			; 00000078H
  000e6	00		 DB	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 4161 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4162 :         return _Mypair._Myval2._Mysize;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 4163 :     }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 4143 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4144 :         return _Mypair._Myval2._Myptr();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4145 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Ptr$3 = -32						; size = 4
__Old_size$ = -20					; size = 4
_this$ = -8						; size = 4
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 4082 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  00010	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4083 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00030	89 4d ec	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 4084 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 4d ec	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00039	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0003c	73 4d		 jae	 SHORT $LN2@push_back

; 4085 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4086 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0003e	8b 45 ec	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00041	83 c0 01	 add	 eax, 1
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 4087 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00052	89 45 e0	 mov	 DWORD PTR __Ptr$3[ebp], eax

; 4088 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00055	8d 45 08	 lea	 eax, DWORD PTR __Ch$[ebp]
  00058	50		 push	 eax
  00059	8b 4d e0	 mov	 ecx, DWORD PTR __Ptr$3[ebp]
  0005c	03 4d ec	 add	 ecx, DWORD PTR __Old_size$[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00065	83 c4 08	 add	 esp, 8

; 4089 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00068	c6 85 17 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
  0006f	8d 85 17 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00075	50		 push	 eax
  00076	8b 4d ec	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00079	8b 55 e0	 mov	 edx, DWORD PTR __Ptr$3[ebp]
  0007c	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00086	83 c4 08	 add	 esp, 8

; 4090 :             return;

  00089	eb 1f		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 4091 :         }
; 4092 : 
; 4093 :         _Reallocate_grow_by(

  0008b	33 c0		 xor	 eax, eax
  0008d	88 85 0b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00093	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  00097	51		 push	 ecx
  00098	0f b6 95 0b ff
	ff ff		 movzx	 edx, BYTE PTR $T1[ebp]
  0009f	52		 push	 edx
  000a0	6a 01		 push	 1
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN1@push_back:

; 4094 :             1,
; 4095 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 4096 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4097 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4098 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4099 :             },
; 4100 :             _Ch);
; 4101 :     }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 4060 :     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN4@operator:

; 4061 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4062 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00030	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00033	77 02		 ja	 SHORT $LN8@operator
  00035	eb 5c		 jmp	 SHORT $LN6@operator
$LN8@operator:
  00037	8b f4		 mov	 esi, esp
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LFGPDMIB@string?5subscript?5out?5of?5range@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00043	6a 00		 push	 0
  00045	68 de 0f 00 00	 push	 4062			; 00000fdeH
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@HPEHFALL@C?3?2Program?5Files?2Microsoft?5Visu@
  0004f	6a 02		 push	 2
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00057	83 c4 18	 add	 esp, 24			; 00000018H
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 01		 jne	 SHORT $LN11@operator
  00066	cc		 int	 3
$LN11@operator:
  00067	8b f4		 mov	 esi, esp
  00069	6a 00		 push	 0
  0006b	68 de 0f 00 00	 push	 4062			; 00000fdeH
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@FHHFGEFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@OADAPGGK@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00085	83 c4 14	 add	 esp, 20			; 00000014H
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	33 c0		 xor	 eax, eax
  00091	75 a4		 jne	 SHORT $LN8@operator
$LN6@operator:
  00093	33 c0		 xor	 eax, eax
  00095	75 93		 jne	 SHORT $LN4@operator

; 4063 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4064 :         return _Mypair._Myval2._Myptr()[_Off];

  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0009f	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 4065 :     }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000ab	3b ec		 cmp	 ebp, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 3663 :     _CONSTEXPR20 basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3664 :         _Mypair._Myval2._Check_offset(_Off);

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 3665 :         _Eos(_Off);

  00036	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 3666 :         return *this;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 3667 :     }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 3271 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3272 :         push_back(_Ch);

  0002a	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 3273 :         return *this;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 3274 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -48					; size = 4
_$S4$ = -33						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3176 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00010	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3177 :         _Tidy_deallocate();

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3178 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3179 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00044	50		 push	 eax
  00045	8d 4d df	 lea	 ecx, DWORD PTR _$S4$[ebp]
  00048	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0004d	8d 45 df	 lea	 eax, DWORD PTR _$S4$[ebp]
  00050	89 45 e8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 3180 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00053	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d d0	 mov	 DWORD PTR __To_delete$[ebp], ecx

; 3181 :         _Mypair._Myval2._Myproxy = nullptr;

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 3182 :         _Delete_plain_internal(_Alproxy, _To_delete);

  00064	8b 45 d0	 mov	 eax, DWORD PTR __To_delete$[ebp]
  00067	50		 push	 eax
  00068	8b 4d e8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00071	83 c4 08	 add	 esp, 8

; 3183 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3184 :     }

  00074	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0007c	52		 push	 edx
  0007d	8b cd		 mov	 ecx, ebp
  0007f	50		 push	 eax
  00080	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@basic_stri
  00086	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008b	58		 pop	 eax
  0008c	5a		 pop	 edx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
  000ab	90		 npad	 1
$LN6@basic_stri:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN5@basic_stri
$LN5@basic_stri:
  000b4	df ff ff ff	 DD	 -33			; ffffffdfH
  000b8	01 00 00 00	 DD	 1
  000bc	00 00 00 00	 DD	 $LN4@basic_stri
$LN4@basic_stri:
  000c0	24		 DB	 36			; 00000024H
  000c1	53		 DB	 83			; 00000053H
  000c2	34		 DB	 52			; 00000034H
  000c3	00		 DB	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT
; _this$ = ecx

; 2643 :     _CONSTEXPR20 void _Construct_empty() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  00010	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2644 :         auto& _My_data = _Mypair._Myval2;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 2645 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00038	50		 push	 eax
  00039	8d 8d 23 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0003f	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  00044	50		 push	 eax
  00045	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00048	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2646 : 
; 2647 :         // initialize basic_string data members
; 2648 :         _My_data._Mysize = 0;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00050	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00057	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0005a	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 2650 :         _My_data._Activate_SSO_buffer();

  00061	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00069	c6 85 17 ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00070	8d 85 17 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00076	50		 push	 eax
  00077	b9 01 00 00 00	 mov	 ecx, 1
  0007c	6b d1 00	 imul	 edx, ecx, 0
  0007f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00082	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0008c	83 c4 08	 add	 esp, 8

; 2654 :     }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 2638 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2639 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2640 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00041	8b 45 10	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	50		 push	 eax
  00048	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004f	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 2641 :     }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
  00076	cc		 int	 3
  00077	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2526 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0001e	b9 06 00 00 00	 mov	 ecx, 6
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0004c	50		 push	 eax
  0004d	0f b6 8d 23 ff
	ff ff		 movzx	 ecx, BYTE PTR $T2[ebp]
  00054	51		 push	 ecx
  00055	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2527 :         _Right._Mypair._Myval2._Check_offset(_Roff);

  00064	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0006b	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 2528 :         _Construct<_Construct_strategy::_From_ptr>(

  00070	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00077	51		 push	 ecx
  00078	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00084	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00089	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2529 :             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
; 2530 :     }

  00095	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a9	59		 pop	 ecx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2499 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0001e	b9 06 00 00 00	 mov	 ecx, 6
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR $T2[ebp]
  00050	50		 push	 eax
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2500 :         _Construct_empty();

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty

; 2501 :     }

  00061	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 04	 add	 ecx, 4
  00026	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2292 :             _STD _Destroy_in_place(_Ptr);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00033	83 c4 04	 add	 esp, 4

; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	33 c0		 xor	 eax, eax
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	89 01		 mov	 DWORD PTR [ecx], eax
  00031	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00034	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00037	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2276 :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2277 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00030	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00033	89 8d 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00039	8d 95 2c ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0003f	52		 push	 edx
  00040	8d 45 0c	 lea	 eax, DWORD PTR __Size$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00049	83 c4 08	 add	 esp, 8
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]

; 2279 :     }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2272 :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2273 :         _Xout_of_range("invalid string position");

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00026	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN1@Xran:

; 2274 :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00030	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00033	73 05		 jae	 SHORT $LN2@Check_offs

; 2261 :             _Xran();

  00035	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN2@Check_offs:
$LN1@Check_offs:

; 2262 :         }
; 2263 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  00010	b9 04 00 00 00	 mov	 ecx, 4
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2244 :         return _Myres > _Small_string_capacity;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 78 18 0f	 cmp	 DWORD PTR [eax+24], 15	; 0000000fH
  00031	76 0c		 jbe	 SHORT $LN3@Large_mode
  00033	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003d	eb 0a		 jmp	 SHORT $LN4@Large_mode
$LN3@Large_mode:
  0003f	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_mode:
  00049	0f b6 85 30 ff
	ff ff		 movzx	 eax, BYTE PTR tv66[ebp]

; 2245 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2235 :         const value_type* _Result = _Bx._Buf;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 04	 add	 eax, 4
  00030	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 2236 :         if (_Large_mode_engaged()) {

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 12		 je	 SHORT $LN2@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0004e	83 c4 04	 add	 esp, 4
  00051	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

  00054	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 2241 :     }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2226 :         value_type* _Result = _Bx._Buf;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 04	 add	 eax, 4
  00030	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         if (_Large_mode_engaged()) {

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 12		 je	 SHORT $LN2@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0004e	83 c4 04	 add	 esp, 4
  00051	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

  00054	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 2232 :     }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 04	 add	 ecx, 4
  00038	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2213 : 
; 2214 :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 2215 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2216 :     // roundup mask for allocated buffers, [0, 15]
; 2217 :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 2218 :                                            : sizeof(value_type) <= 2 ? 7
; 2219 :                                            : sizeof(value_type) <= 4 ? 3
; 2220 :                                            : sizeof(value_type) <= 8 ? 1
; 2221 :                                                                      : 0;
; 2222 :     // capacity in small mode
; 2223 :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 2224 : 
; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_mode_engaged()) {
; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;
; 2232 :     }
; 2233 : 
; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_mode_engaged()) {
; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;
; 2241 :     }
; 2242 : 
; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 2244 :         return _Myres > _Small_string_capacity;
; 2245 :     }
; 2246 : 
; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }
; 2257 : 
; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {
; 2261 :             _Xran();
; 2262 :         }
; 2263 :     }
; 2264 : 
; 2265 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2266 :         // checks whether _Off is in the bounds of [0, size())
; 2267 :         if (_Mysize <= _Off) {
; 2268 :             _Xran();
; 2269 :         }
; 2270 :     }
; 2271 : 
; 2272 :     [[noreturn]] static void _Xran() {
; 2273 :         _Xout_of_range("invalid string position");
; 2274 :     }
; 2275 : 
; 2276 :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2277 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2278 :         return (_STD min)(_Size, _Mysize - _Off);
; 2279 :     }
; 2280 : 
; 2281 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2282 :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 2283 :         // renaming `_String_val` (and fixing the visualizer).
; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00051	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 740  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 741  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00021	83 c8 ff	 or	 eax, -1

; 742  :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 980  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 981  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 982  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0003c	83 c4 04	 add	 esp, 4

; 983  :     }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 974  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN4@deallocate:

; 975  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  0002a	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0002e	75 06		 jne	 SHORT $LN10@deallocate
  00030	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00034	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00036	eb 5c		 jmp	 SHORT $LN6@deallocate
$LN8@deallocate:
  00038	8b f4		 mov	 esi, esp
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00044	6a 00		 push	 0
  00046	68 cf 03 00 00	 push	 975			; 000003cfH
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@IGIKFMFC@C?3?2Program?5Files?2Microsoft?5Visu@
  00050	6a 02		 push	 2
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00058	83 c4 18	 add	 esp, 24			; 00000018H
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	83 f8 01	 cmp	 eax, 1
  00065	75 01		 jne	 SHORT $LN12@deallocate
  00067	cc		 int	 3
$LN12@deallocate:
  00068	8b f4		 mov	 esi, esp
  0006a	6a 00		 push	 0
  0006c	68 cf 03 00 00	 push	 975			; 000003cfH
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@LJPJJNIE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	33 c0		 xor	 eax, eax
  00092	75 a4		 jne	 SHORT $LN8@deallocate
$LN6@deallocate:
  00094	33 c0		 xor	 eax, eax
  00096	75 92		 jne	 SHORT $LN4@deallocate

; 976  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00098	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0009b	50		 push	 eax
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a5	83 c4 08	 add	 esp, 8

; 978  :     }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b1	3b ec		 cmp	 ebp, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 966  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2326 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2327 :     _Xlength_error("string too long");

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00026	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN1@Xlen_strin:

; 2328 : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 471  :     _NODISCARD static constexpr int_type eof() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 472  :         return static_cast<int_type>(EOF);

  00021	83 c8 ff	 or	 eax, -1

; 473  :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 463  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d fc	 lea	 edi, DWORD PTR [ebp-4]
  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 464  :         return _Left == _Right;

  00025	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00028	3b 45 0c	 cmp	 eax, DWORD PTR __Right$[ebp]
  0002b	75 0c		 jne	 SHORT $LN3@eq_int_typ
  0002d	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  00037	eb 0a		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00039	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  00043	0f b6 85 3c ff
	ff ff		 movzx	 eax, BYTE PTR tv65[ebp]

; 465  :     }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z PROC	; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 459  :     _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 460  :         return static_cast<unsigned char>(_Ch);

  00021	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]

; 461  :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ENDP	; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z PROC	; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 455  :     _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 456  :         return static_cast<_Elem>(_Meta);

  00021	0f b6 45 08	 movzx	 eax, BYTE PTR __Meta$[ebp]

; 457  :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ENDP	; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             return _Primary_char_traits::assign(_Left, _Right);
; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;

  00021	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00027	8a 11		 mov	 dl, BYTE PTR [ecx]
  00029	88 10		 mov	 BYTE PTR [eax], dl

; 445  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 385  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 386  :         // find length of null-terminated string
; 387  : #if _HAS_CXX17
; 388  : #ifdef __cpp_char8_t
; 389  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 390  : #if _HAS_U8_INTRINSICS
; 391  :             return __builtin_u8strlen(_First);
; 392  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 393  :             return _Primary_char_traits::length(_First);
; 394  : #endif // ^^^ no u8 intrinsics ^^^
; 395  :         } else
; 396  : #endif // defined(__cpp_char8_t)
; 397  :         {
; 398  :             return __builtin_strlen(_First);
; 399  :         }
; 400  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 401  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _strlen
  0002a	83 c4 04	 add	 esp, 4

; 402  : #endif // ^^^ !_HAS_CXX17 ^^^
; 403  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __31746AB4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00021	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _memcpy
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

  00035	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 68   :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __C27AFEEB_xutility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00025	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	6a 08		 push	 8
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00045	8b 11		 mov	 edx, DWORD PTR [ecx]
  00047	52		 push	 edx
  00048	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0004e	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 256  :     }
; 257  : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __7C4A1519_type_traits
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1584 :     return __builtin_addressof(_Val);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1457 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1450 :     _Container_proxy* _Ptr = nullptr;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1457 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1452 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1453 :         _Ptr = nullptr;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1454 :     }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2F328FEB_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00025	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d f8	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __New_val$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 10		 mov	 DWORD PTR [eax], edx

; 764  :     return _Old_val;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 765  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1233 :     void _Orphan_all_locked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1234 :         _Lockit _Lock(_LOCK_DEBUG);

  00034	8b f4		 mov	 esi, esp
  00036	6a 03		 push	 3
  00038	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1235 :         _Orphan_all_unlocked_v3();

  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1236 :     }

  00050	8b f4		 mov	 esi, esp
  00052	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	52		 push	 edx
  00063	8b cd		 mov	 ecx, ebp
  00065	50		 push	 eax
  00066	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Orphan_all
  0006c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00071	58		 pop	 eax
  00072	5a		 pop	 edx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
  00091	0f 1f 00	 npad	 3
$LN6@Orphan_all:
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN5@Orphan_all
$LN5@Orphan_all:
  0009c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000a0	04 00 00 00	 DD	 4
  000a4	00 00 00 00	 DD	 $LN4@Orphan_all
$LN4@Orphan_all:
  000a8	5f		 DB	 95			; 0000005fH
  000a9	4c		 DB	 76			; 0000004cH
  000aa	6f		 DB	 111			; 0000006fH
  000ab	63		 DB	 99			; 00000063H
  000ac	6b		 DB	 107			; 0000006bH
  000ad	00		 DB	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
__Pnext$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1373 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  00010	b9 09 00 00 00	 mov	 ecx, 9
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1374 :     if (!_Myproxy) { // no proxy, already done

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00030	75 02		 jne	 SHORT $LN5@Orphan_all

; 1375 :         return;

  00032	eb 41		 jmp	 SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1376 :     }
; 1377 : 
; 1378 :     // proxy allocated, drain it
; 1379 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  00034	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003e	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	83 c2 04	 add	 edx, 4
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 ec	 mov	 DWORD PTR __Pnext$2[ebp], eax
  00059	eb 09		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0005b	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4d ec	 mov	 DWORD PTR __Pnext$2[ebp], ecx
$LN4@Orphan_all:
  00064	83 7d ec 00	 cmp	 DWORD PTR __Pnext$2[ebp], 0
  00068	74 0b		 je	 SHORT $LN3@Orphan_all

; 1380 :         _Pnext->_Myproxy = nullptr;

  0006a	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0006d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1381 :     }

  00073	eb e6		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:
$LN1@Orphan_all:

; 1382 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1384 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1385 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1386 : #if _HAS_CXX20
; 1387 :     if (_STD is_constant_evaluated()) {
; 1388 :         _Orphan_all_unlocked_v3();
; 1389 :     } else
; 1390 : #endif // _HAS_CXX20
; 1391 :     {
; 1392 :         _Orphan_all_locked_v3();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3

; 1393 :     }
; 1394 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1395 : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1202 :     _CONSTEXPR20 _Container_base12() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1203 : 
; 1204 :     _Container_base12(const _Container_base12&)            = delete;
; 1205 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1206 : 
; 1207 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1208 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1209 : 
; 1210 :     template <class _Alloc>
; 1211 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1212 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1213 :         _Construct_in_place(*_New_proxy, this);
; 1214 :         _Myproxy            = _New_proxy;
; 1215 :         _New_proxy->_Mycont = this;
; 1216 :     }
; 1217 : 
; 1218 :     template <class _Alloc>
; 1219 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1220 :         // pre: no iterators refer to the existing proxy
; 1221 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1222 :         _Construct_in_place(*_New_proxy, this);
; 1223 :         _New_proxy->_Mycont = this;
; 1224 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1225 :     }
; 1226 : 
; 1227 :     _Container_proxy* _Myproxy = nullptr;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1202 :     _CONSTEXPR20 _Container_base12() noexcept = default;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1194 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx

; 1195 : 
; 1196 :     const _Container_base12* _Mycont       = nullptr;
; 1197 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1194 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 158  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 159  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 160  :     _Bytes += _Non_user_size;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	83 c1 27	 add	 ecx, 39			; 00000027H
  0002d	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00030	89 0a		 mov	 DWORD PTR [edx], ecx

; 161  : 
; 162  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00032	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 4d f8	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003a	b8 04 00 00 00	 mov	 eax, 4
  0003f	6b c8 ff	 imul	 ecx, eax, -1
  00042	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00045	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00048	89 45 ec	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  0004b	b8 04 00 00 00	 mov	 eax, 4
  00050	6b c8 fe	 imul	 ecx, eax, -2
  00053	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00056	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  0005d	75 02		 jne	 SHORT $LN14@Adjust_man
  0005f	eb 64		 jmp	 SHORT $LN6@Adjust_man
$LN14@Adjust_man:
  00061	8b f4		 mov	 esi, esp
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0006d	6a 00		 push	 0
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  00074	83 c0 09	 add	 eax, 9
  00077	50		 push	 eax
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@IGIKFMFC@C?3?2Program?5Files?2Microsoft?5Visu@
  0007d	6a 02		 push	 2
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00085	83 c4 18	 add	 esp, 24			; 00000018H
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	83 f8 01	 cmp	 eax, 1
  00092	75 01		 jne	 SHORT $LN19@Adjust_man
  00094	cc		 int	 3
$LN19@Adjust_man:
  00095	8b f4		 mov	 esi, esp
  00097	6a 00		 push	 0
  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  0009e	83 c0 09	 add	 eax, 9
  000a1	50		 push	 eax
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@LJPJJNIE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b7	83 c4 14	 add	 esp, 20			; 00000014H
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	33 c0		 xor	 eax, eax
  000c3	75 9c		 jne	 SHORT $LN14@Adjust_man
$LN6@Adjust_man:
  000c5	33 c0		 xor	 eax, eax
  000c7	75 82		 jne	 SHORT $LN4@Adjust_man

; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000c9	c7 45 e0 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d0	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	2b 4d ec	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  000d8	89 4d d4	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000db	83 7d d4 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  000df	72 08		 jb	 SHORT $LN16@Adjust_man
  000e1	83 7d d4 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  000e5	77 02		 ja	 SHORT $LN16@Adjust_man
  000e7	eb 64		 jmp	 SHORT $LN12@Adjust_man
$LN16@Adjust_man:
  000e9	8b f4		 mov	 esi, esp
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000f5	6a 00		 push	 0
  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  000fc	83 c0 13	 add	 eax, 19			; 00000013H
  000ff	50		 push	 eax
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@IGIKFMFC@C?3?2Program?5Files?2Microsoft?5Visu@
  00105	6a 02		 push	 2
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0010d	83 c4 18	 add	 esp, 24			; 00000018H
  00110	3b f4		 cmp	 esi, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	83 f8 01	 cmp	 eax, 1
  0011a	75 01		 jne	 SHORT $LN20@Adjust_man
  0011c	cc		 int	 3
$LN20@Adjust_man:
  0011d	8b f4		 mov	 esi, esp
  0011f	6a 00		 push	 0
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  00126	83 c0 13	 add	 eax, 19			; 00000013H
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@LJPJJNIE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0013f	83 c4 14	 add	 esp, 20			; 00000014H
  00142	3b f4		 cmp	 esi, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00149	33 c0		 xor	 eax, eax
  0014b	75 9c		 jne	 SHORT $LN16@Adjust_man
$LN12@Adjust_man:
  0014d	33 c0		 xor	 eax, eax
  0014f	75 8a		 jne	 SHORT $LN10@Adjust_man

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00151	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00154	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00157	89 08		 mov	 DWORD PTR [eax], ecx

; 179  : }

  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5b		 pop	 ebx
  0015c	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00162	3b ec		 cmp	 ebp, esp
  00164	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 89   :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 90   :         return ::operator new(_Bytes);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002a	83 c4 04	 add	 esp, 4

; 91   :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -208						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 63   : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d ec	 lea	 edi, DWORD PTR [ebp-20]
  0000f	b9 05 00 00 00	 mov	 ecx, 5
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __45A7EC28_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 64   :     _THROW(bad_array_new_length{});

  00025	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002b	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00030	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00035	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1@Throw_bad_:

; 65   : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 546  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __09FBC026_limits
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 547  :         return INT_MAX;

  00021	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 548  :     }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00028	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002b	83 e0 01	 and	 eax, 1
  0002e	74 0e		 je	 SHORT $LN2@scalar
  00030	6a 0c		 push	 12			; 0000000cH
  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00023	50		 push	 eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __85F4241F_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :         : bad_alloc("bad array new length")

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00028	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002b	83 e0 01	 and	 eax, 1
  0002e	74 0e		 je	 SHORT $LN2@scalar
  00030	6a 0c		 push	 12			; 0000000cH
  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00023	50		 push	 eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __85F4241F_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  :         : exception(_Message, 1)

  0002a	6a 01		 push	 1
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00028	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002b	83 e0 01	 and	 eax, 1
  0002e	74 0e		 je	 SHORT $LN2@scalar
  00030	6a 0c		 push	 12			; 0000000cH
  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  00010	b9 04 00 00 00	 mov	 ecx, 4
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __85F4241F_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00031	74 0e		 je	 SHORT $LN3@what
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], edx
  0003f	eb 0a		 jmp	 SHORT $LN4@what
$LN3@what:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  0004b	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __85F4241F_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4

; 91   :     }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __85F4241F_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00033	33 c0		 xor	 eax, eax
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 04	 add	 ecx, 4
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 c0 04	 add	 eax, 4
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0004a	83 c1 04	 add	 ecx, 4
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ___std_exception_copy
  00053	83 c4 08	 add	 esp, 8

; 74   :     }

  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __85F4241F_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00033	33 c0		 xor	 eax, eax
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 04	 add	 ecx, 4
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00046	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 168  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __A3D3E4E8_vcruntime_new@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 169  :         (void)_Size;
; 170  :         return _Where;

  00021	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 171  :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\лабы\2 семестр\кпо\лаб.1\dates\dates\main.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __3B25FD95_main@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\лабы\2 семестр\кпо\лаб.1\dates\dates\main.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __3B25FD95_main@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
